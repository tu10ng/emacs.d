#+PROPERTY: header-args :results output none
* some words
config based on [[https://github.com/VitalyAnkh/config][VitalyAnkh]], [[https://github.com/Elilif/.elemacs][Eli]], 

please do not reward me credits if you find this config helpful.
* rudimentary configuration
** Personal information
#+begin_src emacs-lisp
(setq user-full-name "tu10ng"
      user-mail-address "2059734099@qq.com")
#+end_src
** Workaround
#+begin_src emacs-lisp
;; need to becalled before loading smerge
(setq smerge-command-prefix "\C-cv")

(defun open-dir ()
  "open current project dir in windows explorer"
  (interactive)
  (shell-command (concat "start explorer /e,/select,\"" (replace-regexp-in-string "/" "\\\\" (buffer-file-name)) "\"")))

(setq recenter-positions '(top middle bottom))
#+end_src

Test some package & modes
#+begin_src emacs-lisp
;; no use?
;; (kill-ring-deindent-mode -1)

#+end_src
** better defaults
*** simple settings
[[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#use-better-defaults][angrybacon/dotemacs]]
#+begin_src emacs-lisp
(defconst IS-MAC      (eq system-type 'darwin))
(defconst IS-LINUX    (memq system-type '(gnu gnu/linux gnu/kfreebsd berkeley-unix)))
(defconst IS-WINDOWS  (memq system-type '(cygwin windows-nt ms-dos)))
(cond
 (IS-WINDOWS ())
 (IS-LINUX
  (use-package exec-path-from-shell)
  (setq exec-path-from-shell-shell-name "bash")
  (exec-path-from-shell-initialize)))

(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t                               ; Stretch cursor to the glyph width
 indent-tabs-mode nil
 tab-width 4
 )

(setq undo-limit 80000000
      help-at-pt-display-when-idle t
      show-paren-highlight-openparen nil
      bookmark-set-fringe-mark nil
      sentence-end-double-space nil
      delete-by-moving-to-trash t 
      truncate-string-ellipsis "…"
      password-cache-expiry nil   
      resize-mini-windows t
      eldoc-idle-delay 0
      scroll-preserve-screen-position t
      ;; scroll-margin 0
      ;; scroll-conservatively 0
      kill-whole-line t
      word-wrap-by-category t  
      warning-minimum-level  :error 
      confirm-kill-processes nil
      read-process-output-max 1048576  ; cat /proc/sys/fs/pipe-max-size
      inhibit-startup-screen t
      inhibit-startup-message t
      inhibit-startup-buffer-menu t
      initial-buffer-choice nil
      initial-scratch-message nil
      shell-command-prompt-show-cwd 1
      inhibit-compacting-font-caches t
      display-raw-bytes-as-hex t
      redisplay-skip-fontification-on-input t
      use-short-answers t
      y-or-n-p-use-read-key t
      read-char-choice-use-read-key t
      next-line-add-newlines t
      dabbrev-case-replace nil
      max-mini-window-height 1
      kill-read-only-ok t
      )

(put 'upcase-region    'disabled nil)
(put 'downcase-region  'disabled nil)
(put 'narrow-to-defun  'disabled nil)
(put 'narrow-to-page   'disabled nil)
(put 'narrow-to-region 'disabled nil)

(global-subword-mode 1)           
(global-visual-line-mode 1)       

(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode -1)

#+end_src
*** bidi
#+begin_src emacs-lisp
(setq-default bidi-display-reordering nil)
(setq bidi-inhibit-bpa t
      long-line-threshold 1000
      large-hscroll-threshold 1000
      syntax-wholeline-max 1000)
#+end_src
*** rm scratch buffer
#+begin_src emacs-lisp
(setq initial-scratch-message "")
(defun remove-scratch-buffer ()
  (if (get-buffer "*scratch*")
      (kill-buffer "*scratch*")))
(add-hook 'after-change-major-mode-hook 'remove-scratch-buffer)
#+end_src
*** sound
#+begin_src emacs-lisp
(cond
 (IS-WINDOWS
  (set-message-beep 'silent)))
#+end_src
*** frame sizing
#+begin_src emacs-lisp
;; (toggle-frame-maximized)
(set-frame-parameter nil 'fullscreen 'maximized)
(cond
 (IS-WINDOWS ())
 (IS-LINUX (toggle-frame-fullscreen)))
#+end_src
*** auto-customizations
change though customisation interface will not add to =init.el=.
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src
*** all-the-icons
#+begin_src emacs-lisp
(use-package all-the-icons
  :demand t
  :config
  (setq-default all-the-icons-faicon-scale-factor 0.7
                all-the-icons-default-faicon-adjust 0.35
                all-the-icons-material-scale-factor 0.8
                all-the-icons-default-material-adjust 0.1))

#+end_src
*** volatile-highlights
#+begin_src emacs-lisp
(use-package volatile-highlights
  :config
  (volatile-highlights-mode))
#+end_src
*** window
**** split default
#+begin_src emacs-lisp
(setq split-height-threshold nil)         ;don't split vertically
(setq split-width-threshold 0)            ;need to set this bc `split-window-sensibly' will disregard height-threshold

#+end_src
**** shackle
#+begin_src emacs-lisp
;; Customize popwin behavior
(use-package shackle                    ;*customize* not working?
  :hook (after-init . shackle-mode)
  :custom
  (shackle-default-size 0.5)
  (shackle-default-alignment 'bellow)
  (shackle-rules
   '((magit-status-mode    :select t :align right)
     (magit-log-mode       :select t :align below :popup t :same t)
     (magit-rev-mode       :select t :align right)
     ("*quickrun*"         :select t :same nil :popup t)
     (profiler-report-mode :select t)
     (xwidget-webkit-mode  :select t )
     (apropos-mode         :select t :align right :size 0.2)
     (help-mode            :select t :align right)
     (helpful-mode         :select t :align right :popup t :size 0.3)
     (comint-mode          :select t :align right :size 0.2)
     (grep-mode            :select t :align right)
     (rg-mode              :select t :align right)
     (compilation-mode     :select t :align right)
     (Man-mode             :select t :align right)
     (info-mode            :select t :align right :popup t :size 0.5)
     ("*elfeed-entry*"     :select t :align right :popup t :same nil :size 0.5) ;
     ("*eww*"              :select t :align right :popup t :size 0.6)
     ("*Org todo*"         :select t :align right :popup t :size 0.3)
     ("*Org Agenda*"       :select t :align right :popup t :size 0.6)
     ("*devdocs*"          :select t :align right :popup t :size 0.6)
     ("*Shell Command Output*"    :select nil :align bellow :size 0.4)
     ("*Async Shell Command*"     :select nil :align bellow :size 0.4)
     ("*sly-description*"     :select t)
     (".*eshell.*" :select t :align right :popup t :same nil :size 0.3 :regexp t)
     ("*Org-Babel Error Output*"  :select nil :align bellow :size 0.3)
     ("*package update results*"  :select nil :align bellow :size 10)
     ("*Process List*"            :select t   :align bellow :size 0.3)
     ("*Occur*"                   :select t   :align bellow)
     ("\\*eldoc\\( for \\)?.*\\*" :select t :size 0.5 :regexp t))))

;; All `temp-buffer's, e.g. *Completions*, will never mess up window layout.
(use-package help
  :ensure nil
  :hook (after-init . temp-buffer-resize-mode)
  :custom
  (help-window-select t))

#+end_src
*** find-file make-directory
#+begin_src emacs-lisp
(defun my-find-file (orig-fun &rest args)
  (let* ((filename (car args))
         (directory (file-name-directory filename)))
    (unless (null directory)
      (if (not (file-directory-p directory))
          (make-directory directory t)))
    (apply orig-fun args)))

(advice-add 'find-file :around 'my-find-file)

#+end_src
*** gc

#+begin_src emacs-lisp
(use-package gcmh)
(setq gcmh-idle-delay 'auto
      gcmh-auto-idle-delay-factor 100
      gcmh-high-cons-threshold (* 10 1024 1024 1024))
(gcmh-mode 1)


#+end_src
*** emacs c source directory
#+begin_src emacs-lisp
(setq source-directory "/home/tu10ng/Project/emacs-git/src/emacs-git/")
(setq find-function-C-source-directory "/home/tu10ng/Project/emacs-git/src/emacs-git/src/")


#+end_src
*** byte compile
#+begin_src emacs-lisp
;; (setq load-prefer-newer t)
;; (native-compile-prune-cache)

#+end_src
*** mouse 
Thanks to Po Lu, scrolling in emacs is great again!
#+begin_src emacs-lisp
(pixel-scroll-precision-mode 1)
(setq pixel-scroll-precision-large-scroll-height 60
      pixel-scroll-precision-interpolation-factor 3.0)
#+end_src
*** auto-revert
#+begin_src emacs-lisp
(use-package autorevert
  :hook (after-init . global-auto-revert-mode)
  :custom
  (auto-revert-interval 0.3)
  (auto-revert-avoid-polling t)
  (auto-revert-verbose nil)
  (auto-revert-remote-files t)
  (auto-revert-check-vc-info t)
  )

#+end_src
*** auto-save
recommend use with vc to avoid accident lost.
#+begin_src emacs-lisp
(setq auto-save-default nil
      make-backup-files nil
      delete-old-versions t)

(add-to-list 'load-path "~/.emacs.d/site-lisp/auto-save/")
(require 'auto-save)
(setq auto-save-idle 0.5)
(setq auto-save-silent t)
(setq auto-save-delete-trailing-whitespace nil)

(auto-save-enable)

#+end_src
*** Drag text from emacs to other apps
Thanks to Po Lu!
#+begin_src emacs-lisp
(setq
 mouse-drag-and-drop-region-cross-program t
 mouse-drag-and-drop-region t)
#+end_src
*** guess indent
#+begin_src emacs-lisp
(use-package dtrt-indent
  :hook prog-mode
  :config
  (setq dtrt-indent-verbosity 0))
#+end_src
*** indent buffer
#+begin_src emacs-lisp
(defun indent-buffer ()
  (interactive)
  (save-excursion
    (indent-region (point-min) (point-max) nil)))
(global-set-key "\C-\M-\\" 'indent-buffer)

#+end_src
*** compilation buffer
#+begin_src emacs-lisp
(use-package compile
  :ensure nil
  :hook (compilation-filter . colorize-compilation-buffer)
  :config
  (defun colorize-compilation-buffer ()
    "ANSI coloring in compilation buffers."
    (with-silent-modifications
      (ansi-color-apply-on-region compilation-filter-start (point-max))))
  :custom
  (compilation-always-kill t)
  (compilation-scroll-output t)
  ;; Save all buffers on M-x `compile'
  (compilation-ask-about-save nil))

#+end_src
*** treesitter
#+begin_src emacs-lisp
(when (treesit-available-p)
  (message "WARNING: treesit is available"))
#+end_src
*** comment-dwim-2
#+begin_src emacs-lisp
;; (use-package comment-dwim-2
;;   :bind (("M-;" . comment-dwim-2)))

;; (setq comment-dwim-2--inline-comment-behavior 'reindent-comment)

;; (defun comment-dwim-2 (&optional arg)
;;   "Call a comment command according to the context."
;;   (interactive "*P")
;;   (if (use-region-p)
;; 	  (funcall cd2/region-command)
;; 	(if arg
;; 		(cd2/prefix-command)
;;       (if (cd2/fully-commented-line-p)
;; 		  (progn
;; 			(cd2/uncomment-line)
;; 			(when (and (or (eq last-command 'comment-dwim-2)
;; 						   (eq last-command 'org-comment-dwim-2))
;; 					   (not (cd2/empty-line-p))
;; 					   (not (cd2/line-ends-with-multiline-string-p))
;; 					   (not (cd2/fully-commented-line-p)))
;; 			  (if (cd2/line-contains-comment-p)
;; 				  (cd2/inline-comment-command)
;; 				(comment-indent)))) ; Insert inline comment
;; 		(if (and (cd2/line-contains-comment-p)
;; 				 (or (eq last-command 'comment-dwim-2)
;; 					 (eq last-command 'org-comment-dwim-2)))
;; 			(cd2/comment-line)
;;           (cd2/inline-comment-command)
;;           (indent-according-to-mode))))))

#+end_src
*** shell, term
not very good to use
#+begin_src emacs-lisp
;; (cond
;;  (IS-WINDOWS
;;   (setq explicit-shell-file-name "C:/Users/incubator/scoop/shims/bash.exe")
;;   ;; (setq explicit-shell-file-name
;;   ;;       "c:/Windows/System32/WindowsPowerShell/v1.0/powershell.EXE")
;;   ))

(use-package shx)
(shx-global-mode 1)
(setq shx-path-to-convert "magick") ;; convert.exe is deprecated, use magick.exe on windows
#+end_src
*** tmp keybinds
#+begin_src emacs-lisp
(global-set-key (kbd "M-l") (lambda (ARG) (interactive "p") (downcase-word (- ARG))))
(global-set-key (kbd "M-u") (lambda (ARG) (interactive "p") (upcase-word (- ARG))))
(global-set-key (kbd "M-c") (lambda (ARG) (interactive "p") (capitalize-word (- ARG))))

(global-set-key "\C-r" #'query-replace-regexp)
(global-set-key "\M-z" #'zap-up-to-char)

(global-set-key "\C-ct" #'tldr)

(defconst user-git-html-doc-dir "C:/Users/incubator/scoop/apps/git/2.42.0.2/mingw64/share/doc/git-doc/")

(defun linux-www-man (name)
  (interactive
   (let ((name (thing-at-point 'symbol)))
     (list (if (or (null name) current-prefix-arg)
               (read-string "find linux man page of: " name)
             name))))
  (let (page buffer tmp)

    (when (file-exists-p (setq tmp (concat user-git-html-doc-dir name ".html")))
      (setq page (concat "file:///" tmp)))

    (unless page
      (dolist (i '(3 2 1))
        (unless page
          (let* ((fmt "https://man7.org/linux/man-pages/man%d/%s.%d.html")
                 (man (format fmt i name i)))
            (when (url-https-file-exists-p man)
              (setq page man))))))

    (unless page
      (user-error "Failed to find man-page for %s" name))

    (setq buffer (get-buffer-create (format "*man: %s*" name)))

    (pop-to-buffer buffer
                   '(display-buffer-reuse-window (inhibit-same-window t)))
    (goto-char (point-min))
    (unless (re-search-forward (format "^%s(" name) nil t)
      (erase-buffer)
      (url-retrieve page 'eww-render (list page (point-min) (current-buffer) nil)))

    (goto-char (point-min))
    (goto-char (if (re-search-forward "^SYNOPSIS" nil t)
                   (match-beginning 0)
                 (point-min)))))
(cond
 (IS-WINDOWS (global-set-key "\C-cm" #'linux-www-man))
 (IS-LINUX (global-set-key "\C-cm" #'man)))

(global-set-key "\C-xd" #'dired-jump)

(global-set-key "\M-p" #'backward-paragraph)
(global-set-key "\M-n" #'forward-paragraph)
(global-set-key "\M-[" #'backward-sexp)
(global-set-key "\M-]" #'forward-sexp)

(global-set-key (kbd "C-<down-mouse-1>") (lambda (event)
                                           (interactive (list last-command-event))
                                           (posn-set-point (event-end event))
                                           (browse-url (thing-at-point 'url t))))
#+end_src
** emacs configuration
*** complete interface
**** orderless
#+begin_src emacs-lisp
(use-package orderless
  :config
  (defun +orderless--consult-suffix ()
    "Regexp which matches the end of string with Consult tofu support."
    (if (and (boundp 'consult--tofu-char) (boundp 'consult--tofu-range))
        (format "[%c-%c]*$"
                consult--tofu-char
                (+ consult--tofu-char consult--tofu-range -1))
      "$"))

  ;; Recognizes the following patterns:
  ;; * regexp$ (regexp matching at end)
  ;; * .ext (file extension). this is useless if we use "=.ext" or ".ext$" search patterns.
  (defun +orderless-consult-dispatch (word _index _total)
    (cond
     ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
     ((string-suffix-p "$" word)
      `(orderless-regexp . ,(concat (substring word 0 -1) (+orderless--consult-suffix))))
     ;; File extensions
     ((and (or minibuffer-completing-file-name
               (derived-mode-p 'eshell-mode))
           (string-match-p "\\`\\.." word))
      `(orderless-regexp . ,(concat "\\." (substring word 1) (+orderless--consult-suffix))))))

  (orderless-define-completion-style +orderless-with-initialism
    (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion))
                                        (command (styles +orderless-with-initialism))
                                        (variable (styles +orderless-with-initialism))
                                        (symbol (styles +orderless-with-initialism)))
        orderless-component-separator #'orderless-escapable-split-on-space
        orderless-style-dispatchers (list #'+orderless-consult-dispatch
                                          #'orderless-affix-dispatch)))

(setq completion-styles '(orderless partial-completion basic))

(setq completion-category-defaults nil)

(setq orderless-matching-styles '(orderless-literal
                                  orderless-regexp
                                  ;; orderless-flex
                                  orderless-initialism
                                  orderless-prefixes))

#+end_src
**** capf
only use TAB and S-TAB to select candidate and auto insert
corfu will not be tangled with move commands
***** corfu
#+begin_src emacs-lisp
;; TODO
(setq tab-always-indent 'complete)

;; (use-package corfu
;;   :bind
;;   (:map corfu-map
;;         ([remap move-beginning-of-line] . nil)
;;         ([remap move-end-of-line] . nil)
;;         ([remap beginning-of-buffer] . nil)
;;         ([remap end-of-buffer] . nil)
;;         ([remap scroll-down-command] . nil)
;;         ([remap scroll-up-command] . nil)
;;         ([remap next-line] . nil)
;;         ([remap previous-line] . nil)
;;         ([remap newline] . nil)
;;         ("C-a" . nil)
;;         ("C-e" . nil)
;;         ("RET" . nil)
;;         ([ret] . nil)
;;         ("M-p" . nil)
;;         ("M-n" . nil)
;;         ("TAB" . corfu-next)
;;         ([tab] . corfu-next)
;;         ("S-TAB" . corfu-previous)
;;         ([backtab] . corfu-previous)))

;; (setq corfu-auto t
;;       corfu-quit-no-match t
;;       corfu-auto-delay 0.2
;;       corfu-auto-prefix 1
;;       corfu-cycle t
;;       corfu-excluded-modes '(org-mode slime-repl-mode)
;;       corfu-preselect 'prompt
;;       ;; https://emacs-china.org/t/corfu-tab-and-go-eglot-snippet/24473
;;       ;; still have problem when writing rust
;;       ;; corfu-on-exact-match nil
;;       ;; eglot-stay-out-of '(yasnippet)
;;       )

;; (global-corfu-mode 1)

;; (setq corfu-popupinfo-delay 0
;;       corfu-popupinfo-max-height 30)

;; (corfu-popupinfo-mode 1)
#+end_src
***** cape
#+begin_src emacs-lisp
;; (use-package cape
;;   :commands (cape-file)
;;   :init
;;   (add-to-list 'completion-at-point-functions #'cape-file))

;; (defun ispell-completion-at-point ())
#+end_src
***** company
#+begin_src emacs-lisp
(use-package company
  :hook (slime-repl-mode . company-mode)
  :bind
  (:map global-map
        ("C-M-i" . company-complete))
  (:map company-active-map
        ;; ("TAB" . company-select-next-or-abort)
        ;; ("<backtab>" . company-select-previous-or-abort)
        ;; ("<tab>" . nil)
        ;; ("RET" . nil)
        ;; ("<return>" . nil)
        ("C-p" . nil)
        ("C-n" . nil)
        ;; ("C-s" . nil)
        ;; ("C-h" . nil)
        ("C-v" . nil)
        ([remap scroll-up-command] . nil)
        ([remap scroll-down-command] . nil)
        ("M-v" . nil)
        ("M-p" . nil)
        ("M-n" . nil))
  :config
  ;; (setq-default company-backends '(company-capf company-files))
  (setq-default company-dabbrev-downcase nil)
  (setq-default company-tooltip-align-annotations t
                company-format-margin-function nil)
  ;; (setq-default company-frontends
  ;;               '(company-pseudo-tooltip-frontend
  ;;                 company-echo-metadata-frontend))

  (setq company-backends
        '(;; company-bbdb
          ;; company-semantic
          ;; company-cmake
          ;; company-yasnippet
          company-files
          company-capf
          company-etags
          (company-dabbrev-code company-gtags company-etags company-keywords)
          ;; company-clang
          ;; company-dabbrev-code
          ))

  (setq company-idle-delay 0.01
        company-minimum-prefix-length 1
        company-selection-wrap-around t
        company-tooltip-limit 10
        company-tooltip-flip-when-above t
        company-tooltip-align-annotations t
        company-dabbrev-other-buffers nil
        company-dabbrev-ignore-case t
        company-files-exclusions '(".git/" 
                                   ".gitignore"
                                   ".gitmodules")
        company-transformers '(;; delete-consecutive-dups
                               company-sort-by-occurrence
                               company-sort-by-backend-importance
                               company-sort-prefer-same-case-prefix)
        company-files-chop-trailing-slash nil
        company-format-margin-function #'company-text-icons-margin)

  ;; ⭐ Don't let `company-elisp' quickhelp hijack `*Help*' buffer
  (defvar k-help-buffer-override nil)

  (define-advice company-capf
      (:around (orig &rest args) k-help-buffer-override)
    (let ((k-help-buffer-override "*company-documentation*"))
      (apply orig args)))

  (define-advice help-buffer
      (:around (orig) k-help-buffer-override)
    (or (when k-help-buffer-override
          (get-buffer-create k-help-buffer-override))
        (funcall orig))))

(add-hook 'org-mode-hook #'(lambda () (setq-local company-minimum-prefix-length 5)))
(global-company-mode)
(add-hook 'company-mode-hook 'company-tng-mode)
;; (define-advice company-capf (:around (orig-fun &rest args) set-completion-styles)
;;   (let ((completion-styles '(flex partial-completion orderless)))
;;     (apply orig-fun args)))

(add-hook 'emacs-lisp-mode-hook
          #'(lambda ()
              (setq-local company-idle-delay 0.4)))

(add-hook 'comint-mode-hook
          #'(lambda ()
              (company-mode -1)))

(add-hook 'eshell-mode-hook
          #'(lambda ()
              (company-mode -1)))


(use-package company-quickhelp)
(company-quickhelp-mode 1)
(setq company-quickhelp-delay 0.7)
#+end_src
**** vertico
***** vertico common, minibuffer
#+begin_src emacs-lisp
(define-key minibuffer-inactive-mode-map [mouse-1] nil)

(use-package vertico
  :hook (after-init . vertico-mode)
  :config
  (setq vertico-count 15)
  (face-spec-set 'vertico-current
                 '((((background light))
                    :background "#d8d8d8" :extend t)
                   (t
                    :background "#454545" :extend t))
                 'face-defface-spec))

;; persist history over emacs restarts.
(savehist-mode 1)

;; Add prompt indicator to `completing-read-multiple'.
;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
(defun crm-indicator (args)
  (cons (format "[CRM%s] %s"
                (replace-regexp-in-string
                 "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                 crm-separator)
                (car args))
        (cdr args)))
(advice-add #'completing-read-multiple :filter-args #'crm-indicator)

;; Do not allow the cursor in the minibuffer prompt
(setq minibuffer-prompt-properties
      '(read-only t cursor-intangible t face minibuffer-prompt))
(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

(setq read-extended-command-predicate
      #'command-completion-default-include-p)
(setq enable-recursive-minibuffers t)
(minibuffer-depth-indicate-mode 1)
#+end_src
***** vertico-directory
delete directory name in one go
#+begin_src emacs-lisp
(use-package vertico-directory
  :after vertico
  :ensure nil
  :bind (:map vertico-map
              ("RET" . vertico-directory-enter)
              ("DEL" . vertico-directory-delete-char)
              ("M-DEL" . vertico-directory-delete-word))
  ;; Tidy shadowed file names
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))
#+end_src
***** Rich annotation
#+begin_src emacs-lisp
(use-package marginalia)
(marginalia-mode)
#+end_src
**** lsp
#+begin_src emacs-lisp
(use-package eglot)
(setq eglot-stay-out-of '(company)) ;; dont change company capf
(setq eglot-extend-to-xref t)
(setq eglot-ignored-server-capabilities '(:documentOnTypeFormattingProvider))

(add-to-list
 'completion-category-overrides '((eglot (styles orderless))))
(global-set-key (kbd "C-c ea") #'eglot-code-actions)
(global-set-key (kbd "C-c er") #'eglot-rename)
(global-set-key (kbd "C-c ee") #'eglot-reconnect)

(use-package consult-eglot)

(add-hook 'prog-mode-hook               ;eglot
          (lambda ()
            (if (derived-mode-p
                 'python-base-mode
                 'java-mode
                 'haskell-mode
                 'rust-mode
                 'rust-ts-mode
                 'python-ts-mode
                 'LaTeX-mode
                 'typescript-mode
                 ;; 'emacs-lisp-mode
                 ;; 'racket-mode
                 ;; 'lisp-mode
                 ;; 'makefile-mode
                 'c-mode
                 ;; 'asm-mode
                 ;; 'nasm-mode
                 ;; 'verilog-mode
                 )
                (eglot-ensure))))

(add-hook 'lalrpop-mode-hook
          #'(lambda () (eglot--managed-mode-off)))

#+end_src
*** visual settings
**** font
#+begin_src emacs-lisp
;; (set-face-attribute 'default nil :font "Source Code Pro:pixelsize=20")

(use-package cnfonts)
(cnfonts-mode 1)
;; 添加两个字号增大缩小的快捷键
;; (define-key cnfonts-mode-map (kbd "C-x C--") #'cnfonts-decrease-fontsize)
;; (define-key cnfonts-mode-map (kbd "C-x C-=") #'cnfonts-increase-fontsize)

(setq use-default-font-for-symbols t)

(defun cfs-set-symbol-fonts (fontsizes-list)
  (set-fontset-font t 'symbol "Source Code Pro" nil 'append)
  (set-fontset-font t 'symbol "Symbola" nil 'append)
  (set-fontset-font t 'unicode "Source Code Pro" nil 'append)
  (set-fontset-font t 'unicode "Symbola" nil 'append))

(add-hook 'cnfonts-set-font-finish-hook 'cfs-set-symbol-fonts)

(defun font-installed-p (font-name)
  "Check if font with FONT-NAME is available."
  (find-font (font-spec :name font-name)))

;; https://emacs-china.org/t/emacs/22193
;; ✝✚✡☥⎈☭☪☮☺☹ ☯☰☱☲☳☴☵☶☷
;; ⇐⇒⇑⇓⇔⇗⇦⇨⇧
;; ðɫŋɹɾƩθtʒæɑəəɚɜɛɝɪɪ̈ɒɔʊʊ̈ʌ𝑥٪
#+end_src
**** theme
loading theme is remarkably slow
#+begin_src emacs-lisp
(load-theme 'tango-dark)

;; tweek
;; prefer green on black(or gray)
;; blue is the color of the wisdom(conosuba)
(set-face-attribute 'mode-line nil
                    :foreground "green"
                    :background "DarkBlue")
(defun tu10ng/theme-toggle-white-on-gray ()
  (interactive)
  (set-face-attribute 'default nil
                      :foreground "white"
                      :background "#252525")
  (run-with-timer (* 10 60) nil
                  (lambda ()
                    (set-face-attribute 'default nil
                                        :foreground "green"
                                        :background "#252525"))))

(set-face-attribute 'default nil
                    :foreground "green"
                    :background "#252525")

#+end_src
**** modeline content
#+begin_src emacs-lisp
(defun k-fill-right (string)
  "Prepend a variable space to STRING to make it right-aligned."
  (let* ((width (string-pixel-width string)))
    (concat (propertize " " 'display
                        `(space :align-to (- right-fringe (,width))))
            string)))

(defun k-truncate-string-to-width (string pixel-width)
  "Truncate STRING to PIXEL-WIDTH.
Use binary search."
  (if (> (string-pixel-width string) pixel-width)
      (let* ((a 1) a-result
             (b (length string)))
        (while (> b (+ a 1))
          (let* ((c (ceiling (+ a b) 2))
                 (result (concat (substring string 0 c) (truncate-string-ellipsis))))
            (if (> (string-pixel-width result) pixel-width)
                (setq b c)
              (setq a c a-result result))))
        a-result)
    string))

(defun k-pad-mode-line-format (format &optional right-format)
  "Format the mode line as a string according to FORMAT and RIGHT-FORMAT.
FORMAT is left-aligned and RIGHT-FORMAT is right-aligned.  Add
padding space at the left and right of the mode line so that the
edge of the mode line align with left and right fringe."
  (unless (stringp format)
    (setq format (format-mode-line format)))
  (when right-format
    (unless (stringp right-format)
      (setq right-format (format-mode-line right-format)))
    (setq format (concat format (k-fill-right right-format))))
  `(#(" " 0 1 (face default display (space :width left-fringe)))
    ;; ,(truncate-string-to-width
    ;;   format
    ;;   (window-text-width (get-buffer-window (current-buffer)))
    ;;   nil nil (truncate-string-ellipsis))
    ,(k-truncate-string-to-width format (window-text-width (get-buffer-window) t))
    #(" " 0 1 (display (space :align-to right)))
    #(" " 0 1 (face default display (space :width right-fringe)))))

(defvar k-selected-window nil)

(defun k-set-selected-window ()
  (when (not (minibuffer-window-active-p (frame-selected-window)))
    (setq k-selected-window (frame-selected-window))))

(defsubst k-mode-line-selected-p ()
  (eq (selected-window) k-selected-window))

(add-hook 'window-state-change-hook 'k-set-selected-window)

(defvar-local k-mode-line-format-left
    '(""
      (:propertize "%b" face mode-line-buffer-id)
      " \t"
      mode-line-misc-info))

(defvar-local k-mode-line-format-right
    '(" "
      current-input-method-title " "
      mode-name mode-line-process
      "  "
      (:eval (if (k-mode-line-selected-p) #("%c" 0 2 (face mode-line-emphasis))
               "%c"))
      "+"
      (:eval (number-to-string (- (line-end-position) (point))))
      
      (#(" %l/" 0 3 (face mode-line-highlight))
       (:propertize (:eval (number-to-string (line-number-at-pos (point-max))))
                    face bold))))

(setq-default mode-line-misc-info
              '((slime-mode (:eval (slime-mode-line))))
              mode-line-format
              `(:eval (k-pad-mode-line-format k-mode-line-format-left k-mode-line-format-right))
              tab-line-format nil)
#+end_src
**** per buffer echo
#+begin_src emacs-lisp
#+end_src
**** misc
#+begin_src emacs-lisp
(use-package hl-todo)
(global-hl-todo-mode)
(setq-default visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
(setq-default underline-minimum-offset 10)

#+end_src
*** helper macros
**** use-package
#+begin_src emacs-lisp
(defmacro tu10ng/use-package-multi (&rest packages)
  `(progn
     ,@(mapcar #'(lambda (package)
                   `(use-package ,package))
               packages)))

;; (tu10ng/use-package-multi
;;  systemd
;;  ahk-mode
;;  ebnf-mode
;;  )
;;
;;  -->
;;
;; (progn
;;   (use-package systemd)
;;   (use-package ahk-mode)
;;   (use-package ebnf-mode))


#+end_src
**** doom macros
#+begin_src emacs-lisp
(defmacro defadvice! (symbol arglist &optional docstring &rest body)
  "Define an advice called SYMBOL and add it to PLACES.

ARGLIST is as in `defun'. WHERE is a keyword as passed to `advice-add', and
PLACE is the function to which to add the advice, like in `advice-add'.
DOCSTRING and BODY are as in `defun'.

\(fn SYMBOL ARGLIST &optional DOCSTRING &rest [WHERE PLACES...] BODY\)"
  (declare (doc-string 3) (indent defun))
  (unless (stringp docstring)
    (push docstring body)
    (setq docstring nil))
  (let (where-alist)
    (while (keywordp (car body))
      (push `(cons ,(pop body) (ensure-list ,(pop body)))
            where-alist))
    `(progn
       (defun ,symbol ,arglist ,docstring ,@body)
       (dolist (targets (list ,@(nreverse where-alist)))
         (dolist (target (cdr targets))
           (advice-add target (car targets) #',symbol))))))

(defmacro after! (package &rest body)
  "Evaluate BODY after PACKAGE have loaded.

PACKAGE is a symbol (or list of them) referring to Emacs features (aka
packages). PACKAGE may use :or/:any and :and/:all operators. The precise format
is:

- An unquoted package symbol (the name of a package)
    (after! helm BODY...)
- An unquoted, nested list of compound package lists, using any combination of
  :or/:any and :and/:all
    (after! (:or package-a package-b ...)  BODY...)
    (after! (:and package-a package-b ...) BODY...)
    (after! (:and package-a (:or package-b package-c) ...) BODY...)
- An unquoted list of package symbols (i.e. BODY is evaluated once both magit
  and git-gutter have loaded)
    (after! (magit git-gutter) BODY...)
  If :or/:any/:and/:all are omitted, :and/:all are implied.

This emulates `eval-after-load' with a few key differences:

1. No-ops for package that are disabled by the user (via `package!') or not
   installed yet.
2. Supports compound package statements (see :or/:any and :and/:all above).

Since the contents of these blocks will never by byte-compiled, avoid putting
things you want byte-compiled in them! Like function/macro definitions."
  (declare (indent defun) (debug t))
  (if (symbolp package)
      (unless (memq package (bound-and-true-p doom-disabled-packages))
        (list (if (or (not (bound-and-true-p byte-compile-current-file))
                      (require package nil 'noerror))
                  #'progn
                #'with-no-warnings)
              `(with-eval-after-load ',package ,@body)))
    (let ((p (car package)))
      (cond ((memq p '(:or :any))
             (macroexp-progn
              (cl-loop for next in (cdr package)
                       collect `(after! ,next ,@body))))
            ((memq p '(:and :all))
             (dolist (next (reverse (cdr package)) (car body))
               (setq body `((after! ,next ,@body)))))
            (`(after! (:and ,@package) ,@body))))))

#+end_src
*** helper functions
#+begin_src emacs-lisp
(defun k-run-helper-command (command name &optional continuation silent)
  "Run helper shell COMMAND in buffer with NAME.
Run CONTINUATION once the shell process exited.
If SILENT is non-nil, do not display the NAME buffer."
  (require 'comint)
  (with-current-buffer
      (let ((display-comint-buffer-action
             (if silent
                 '(display-buffer-no-window (allow-no-window . t))
               '(nil (inhibit-same-window . t)))))
        (save-selected-window
          (shell name)))
    (add-hook 'comint-output-filter-functions 'comint-truncate-buffer)
    (set-process-sentinel (get-buffer-process (current-buffer))
			              (lambda (_proc _status)
                            (when continuation
                              (funcall continuation))))
    (goto-char (point-max))
    (comint-send-string (get-buffer-process (current-buffer))
                        (concat command "\n"))))
#+end_src
*** proxy
comment out, uses v2raya's transparent proxy
#+begin_src emacs-lisp
;; (setq url-proxy-services
;;       '(("http" . "127.0.0.1:8889")
;;         ("https" . "127.0.0.1:8889"))
;;       )
#+end_src
*** eww, browse url, browser
#+begin_src emacs-lisp
(cond 
 (IS-WINDOWS (setq browse-url-browser-function #'browse-url-default-browser))
 (IS-LINUX (setq browse-url-browser-function #'eww-browse-url)))


#+end_src
** other things
*** interaction
#+begin_src emacs-lisp
(defun tu10ng/copy-file-path ()
  "if C-u, we copy windows flavor path"
  (interactive)
  (when buffer-file-name
    (let ((path (file-truename buffer-file-name)))
      (kill-new path)
      (message path))))
  
#+end_src
*** restart emacs
#+begin_src emacs-lisp
(use-package restart-emacs)
(defun restart-emacs-reopen-current-file ()
  "restart emacs then reopen the file being visited when casting this command.
if the buffer isn't a file, simply restart emacs."
  (interactive)
  (if (buffer-file-name)
      (restart-emacs (split-string (buffer-file-name)))
    (restart-emacs)))

#+end_src
*** close-paren
#+begin_src emacs-lisp
(defun tu10ng/close-paren ()
  (interactive)
  (let ((matching-delimiter nil))
    (while (ignore-errors
             (save-excursion
               (backward-up-list 1)
               (setq matching-delimiter (cdr (syntax-after (point)))))
             t)
      (insert-char matching-delimiter))))

(defun tu10ng/insert-paren-around-last-word ()
  (interactive)
  (save-excursion
    (backward-word)
    (insert "("))
  (insert ")"))

(global-set-key "\C-]" #'tu10ng/insert-paren-around-last-word)
(global-set-key (kbd "<C-return>") #'(lambda ()
                                       (interactive)
                                       (tu10ng/close-paren)
                                       (tu10ng/open-below)))

#+end_src
*** C-xk kill-buffer
#+begin_src emacs-lisp
(advice-add
 #'kill-current-buffer
 :after
 #'(lambda () (ignore-errors
                (delete-window))))

(global-set-key (kbd "C-x k") 'kill-current-buffer)
#+end_src
*** restore session
#+BEGIN_SRC emacs-lisp
;; Back to the previous position
(use-package saveplace
  :hook (after-init . save-place-mode))

(setq save-place-limit 3000)

#+end_src
*** recent file
#+begin_src emacs-lisp
(use-package recentf
  :hook (after-init . recentf-mode)
  :custom
  (recentf-max-saved-items 3000)
  (recentf-auto-cleanup 'never)
  (recentf-exclude '( ;; Folders on MacOS start
                     "^/private/tmp/"
                     "^/var/folders/"
                     ;; Folders on MacOS end
                     "^/tmp/"
                     "/ssh\\(x\\)?:"
                     "/su\\(do\\)?:"
                     "^/usr/include/"
                     "/TAGS\\'"
                     "COMMIT_EDITMSG\\'")))
#+END_SRC
*** tmp daemon server
#+begin_src emacs-lisp
(require 'server)
(or (eq (server-running-p) t)
    (server-start))
#+end_src
*** system daemon
For running a systemd service for a Emacs server I have the following
#+name: emacsclient service
#+begin_src systemd :tangle ~/.config/systemd/user/emacs.service :mkdirp yes
[Unit]
Description=Emacs server daemon
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=sh -c 'emacs --daemon && emacsclient -c --eval "(delete-frame)"'
ExecStop=/usr/bin/emacsclient --no-wait --eval "(progn (setq kill-emacs-hook nil) (kill emacs))"
Restart=on-failure
Environment=COLORTERM=truecolor

[Install]
WantedBy=default.target
#+end_src
which is then enabled by
#+begin_src shell :tangle (if (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled emacs.service")) "no" "setup.sh")
systemctl --user disable emacs.service
#+end_src

For some reason if a frame isn't opened early in the initialisation process, the
daemon doesn't seem to like opening frames later --- hence the ~&& emacsclient~
part of the =ExecStart= value.
It can now be nice to use this as a 'default app' for opening files. If we add
an appropriate desktop entry, and enable it in the desktop environment.

#+begin_src conf :tangle ~/.local/share/applications/emacs-client.desktop :mkdirp yes
[Desktop Entry]
Name=Emacs client
GenericName=Text Editor
Comment=A flexible platform for end-user applications
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
Exec=emacsclient -create-frame --alternate-editor="" --no-wait %F
Icon=emacs
Type=Application
Terminal=false
Categories=TextEditor;Utility;
StartupWMClass=Emacs
Keywords=Text;Editor;
X-KDE-StartupNotify=false
#+end_src
*** Emacs client wrapper
I frequently want to make use of Emacs while in a terminal emulator. To make
this easier, I can construct a few handy aliases.

However, a little convenience script in =~/.local/bin= can have the same effect,
be available beyond the specific shell I plop the alias in, then also allow me
to add a few bells and whistles --- namely:
+ Accepting stdin by putting it in a temporary file and immediately opening it.
+ Guessing that the =tty= is a good idea when ~$DISPLAY~ is unset (relevant with SSH
  sessions, among other things).
+ With a whiff of 24-bit color support, sets ~TERM~ variable to a =terminfo= that
  (probably) announces 24-bit color support.
+ Changes GUI =emacsclient= instances to be non-blocking by default (~--no-wait~),
  and instead take a flag to suppress this behaviour (~-w~).

I would use =sh=, but using arrays for argument manipulation is just too
convenient, so I'll raise the requirement to =bash=. Since arrays are the only
'extra' compared to =sh=, other shells like =ksh= etc. should work too.

#+name: e
#+begin_src shell :tangle ~/.local/bin/e :mkdirp yes :tangle-mode (identity #o755) :comments no
#!/usr/bin/env bash
force_tty=false
force_wait=false
stdin_mode=""

args=()

while :; do
    case "$1" in
        -t | -nw | --tty)
            force_tty=true
            shift ;;
        -w | --wait)
            force_wait=true
            shift ;;
        -m | --mode)
            stdin_mode=" ($2-mode)"
            shift 2 ;;
        -h | --help)
            echo -e "\033[1mUsage: e [-t] [-m MODE] [OPTIONS] FILE [-]\033[0m

Emacs client convenience wrapper.

\033[1mOptions:\033[0m
\033[0;34m-h, --help\033[0m            Show this message
\033[0;34m-t, -nw, --tty\033[0m        Force terminal mode
\033[0;34m-w, --wait\033[0m            Don't supply \033[0;34m--no-wait\033[0m to graphical emacsclient
\033[0;34m-\033[0m                     Take \033[0;33mstdin\033[0m (when last argument)
\033[0;34m-m MODE, --mode MODE\033[0m  Mode to open \033[0;33mstdin\033[0m with

Run \033[0;32memacsclient --help\033[0m to see help for the emacsclient."
            exit 0 ;;
        --*=*)
            set -- "$@" "${1%%=*}" "${1#*=}"
            shift ;;
        ,*)
            if [ "$#" = 0 ]; then
                break; fi
            args+=("$1")
            shift ;;
    esac
done

if [ ! "${#args[*]}" = 0 ] && [ "${args[-1]}" = "-" ]; then
    unset 'args[-1]'
    TMP="$(mktemp /tmp/emacsstdin-XXX)"
    cat > "$TMP"
    args+=(--eval "(let ((b (generate-new-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"$TMP\") (delete-file \"$TMP\")${stdin_mode})")
fi

if [ -z "$DISPLAY" ] || $force_tty; then
    # detect terminals with sneaky 24-bit support
    if { [ "$COLORTERM" = truecolor ] || [ "$COLORTERM" = 24bit ]; } \
           && [ "$(tput colors 2>/dev/null)" -lt 257 ]; then
        if echo "$TERM" | grep -q "^\w\+-[0-9]"; then
            termstub="${TERM%%-*}"; else
            termstub="${TERM#*-}"; fi
        if infocmp "$termstub-direct" >/dev/null 2>&1; then
            TERM="$termstub-direct"; else
            TERM="xterm-direct"; fi # should be fairly safe
    fi
    emacsclient --tty -create-frame --alternate-editor="" "${args[@]}"
else
    if ! $force_wait; then
        args+=(--no-wait); fi
    emacsclient -create-frame --alternate-editor="" "${args[@]}"
fi
#+end_src
Now, to set an alias to use =e= with magit, and then for maximum laziness we can
set aliases for the terminal-forced variants.
#+begin_src shell :tangle no
alias m='e --eval "(progn (magit-status) (delete-other-windows))"'
alias mt="m -t"
alias et="e -t"
#+end_src
*** symbol overlay 
#+begin_src emacs-lisp
(use-package symbol-overlay)

(setq symbol-overlay-idle-time 0.01)
(add-hook 'prog-mode-hook #'symbol-overlay-mode)
#+end_src
*** visible/highlight mark
#+begin_src emacs-lisp
(defface visible-mark-face1
  '((((type tty) (class mono)))
    (t (:background "gray")))
  "Example face which can be customized and added to subsequent face lists."
  :group 'visible-mark)
(defface visible-mark-face2
  '((((type tty) (class mono)))
    (t (:background "gray60")))
  "Example face which can be customized and added to subsequent face lists."
  :group 'visible-mark)

(use-package visible-mark)
(global-visible-mark-mode 1)
(setq visible-mark-max 2)
(setq visible-mark-faces `(visible-mark-face1
			               visible-mark-face2))
#+end_src
*** count chars
#+begin_src emacs-lisp
(defun count-char-stats (&optional case-sensitive)
  (interactive "P")
  (message "case-sensitive: %s" case-sensitive)
  (let ((chars (make-char-table 'counting 0)) 
        current)
    (cl-labels ((%collect-statistics
                 ()
                 (goto-char (point-min))
                 (while (not (eobp))
                   (goto-char (1+ (point)))
                   (setf current (preceding-char))
                   (set-char-table-range
                    chars current
                    (1+ (char-table-range chars current))))))
      (if case-sensitive
          (save-excursion (%collect-statistics))
        (let ((contents (buffer-substring-no-properties
                         (point-min) (point-max))))
          (with-temp-buffer
            (insert contents)
            (upcase-region (point-min) (point-max))
            (%collect-statistics)))))
    (with-current-buffer (get-buffer-create "*character-statistics*")
      (erase-buffer)
      (insert "| character | occurences |
               |-----------+------------|\n")
      (map-char-table
       (lambda (key value)
         (when (and (numberp key) (not (zerop value)))
           (cl-case key
             (?\n)
             (?\| (insert (format "| \\vert | %d |\n" value)))
             (otherwise (insert (format "| '%c' | %d |\n" key value))))))
       chars)
      (org-mode)
      (indent-region (point-min) (point-max))
      (goto-char 56)
      (org-table-sort-lines nil ?a)
      (org-cycle)
      ;; (goto-char 79)
      ;; (org-table-sort-lines nil ?N)
      )
    (pop-to-buffer "*character-statistics*")))


#+end_src
* packages
** INTRUCTIONS
This is where you install packages.
This file shouldn't be byte compiled. TODO: why?
begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
end_src
*** package in melpa/elpa/emacsmirror
#+begin_src emacs-lisp

#+end_src
*** package from git repo
** convenience
*** avy
What a wonderful way to jump to buffer positions.
#+begin_src emacs-lisp
(use-package avy)
(setq avy-all-windows nil
      avy-timeout-seconds 0.3)
(global-set-key (kbd "C-M-;") #'avy-goto-subword-1)
(global-set-key (kbd "C-;") 'avy-goto-char-in-line)


#+end_src
*** goto-last-change
#+begin_src emacs-lisp
(use-package goto-last-change
  :bind ("M-'" . goto-last-change))

#+end_src
*** which-key
#+begin_src emacs-lisp
(use-package which-key
  :disabled t
  :config
  (which-key-mode)
  (setq which-key-idle-delay 0.6
	    which-key-idle-secondary-delay 0
	    which-key-sort-order 'which-key-prefix-then-key-order
	    ))
#+end_src
*** meow (custom keybindings)
#+begin_src emacs-lisp
;; TODO M-; should enter edit mode, insert mode still block cursor, one key to change window focus, keypad mode should default enter C-x
;; TODO put in seperate file and load
(defun tu10ng/meow-find-back (n ch &optional expand)
  "Find the next N char read from minibuffer."
  (interactive "p\ncFind:")
  (let ((n (- n)))
    (let* ((case-fold-search nil)
	       (ch-str (if (eq ch 13) "\n" (char-to-string ch)))
	       (beg (point))
	       end)
      (save-mark-and-excursion
	    (setq end (search-forward ch-str nil t n)))
      (if (not end)
	      (message "char %s not found" ch-str)
	    (thread-first
	      (meow--make-selection '(select . find)
				                beg end expand)
	      (meow--select))
	    (setq meow--last-find ch)
	    (meow--maybe-highlight-num-positions
	     '(meow--find-continue-backward . meow--find-continue-forward))))))

(defun tu10ng/open-below()
  (interactive)
  (end-of-line)
  (open-line 1)
  (call-interactively 'next-line 1)
  (if (not (member major-mode '(haskell-mode org-mode literate-haskell-mode)))
      (indent-according-to-mode)
    (beginning-of-line)))

(defun tu10ng/open-above()
  (interactive)
  (beginning-of-line)
  (open-line 1)
  (if (not (member major-mode '(haskell-mode org-mode literate-haskell-mode)))
      (indent-according-to-mode)
    (beginning-of-line)))

(global-set-key "\C-o" 'tu10ng/open-below)
(global-set-key "\M-o" 'tu10ng/open-above)

(defun tu10ng/kill-sexp-save ()
  (interactive)
  (save-excursion
    (kill-sexp)
    (yank)))

(global-set-key (kbd "M-k") #'tu10ng/kill-sexp-save)
(global-set-key (kbd "C-c C-o") #'browse-url)
(global-set-key (kbd "M-{") #'backward-page)
(global-set-key (kbd "M-}") #'forward-page)

#+end_src
*** quickrun
#+begin_src emacs-lisp
(use-package quickrun
  :bind ("C-c r" . quickrun))
(setq quickrun-timeout-seconds 5)
#+end_src
*** other-window
#+begin_src emacs-lisp

(defun tu10ng/other-window (COUNT &optional ALL-FRAMES INTERACTIVE)
  ""
  (interactive "p\ni\np")
  (if (= (length (window-list-1)) 1)
      (consult-buffer-other-window)
    (other-window COUNT ALL-FRAMES INTERACTIVE)))

(global-set-key "\M-i" #'tu10ng/other-window)
#+end_src
*** split-window-right
#+begin_src emacs-lisp
(advice-add 'split-window-right :after
            (lambda (&rest _arg) (other-window 1)))

#+end_src
*** move-text
#+begin_src emacs-lisp
(use-package move-text)
(move-text-default-bindings)

(defun indent-region-advice (&rest ignored)
  (let ((deactivate deactivate-mark))
    (if (region-active-p)
        (indent-region (region-beginning) (region-end))
      (indent-region (line-beginning-position) (line-end-position)))
    (setq deactivate-mark deactivate)))

(advice-add 'move-text-up :after 'indent-region-advice)
(advice-add 'move-text-down :after 'indent-region-advice)




#+end_src
*** smart-hungry-delete
#+begin_src emacs-lisp
(use-package smart-hungry-delete
  :bind
  (:map prog-mode-map
        (("<backspace>" . smart-hungry-delete-backward-char)
         (("C-d" . smart-hungry-delete-forward-char))))
  (:map text-mode-map
        (("<backspace>" . smart-hungry-delete-backward-char)
         (("C-d" . smart-hungry-delete-forward-char))))
  :init
  (smart-hungry-delete-add-default-hooks))

(setq smart-hungry-delete-major-mode-dedent-function-alist
      '((python-mode . (lambda ()
                         (interactive)
                         (if (bolp)
                             (python-indent-dedent-line-backspace 1)
                           (python-indent-dedent-line-backspace (current-column)))))))
#+end_src
*** delsel
Delete selection when we type or paste.
#+begin_src emacs-lisp
(use-package delsel
  :config
  (delete-selection-mode))

#+end_src
*** shebang
#+begin_src emacs-lisp
(defun tu10ng/shebang (program)
  "insert '#!/usr/bin/env PROGRAM'"
  (interactive "sProgram name: ")
  (insert "#!/usr/bin/env ")
  ;; (shell-command (concat "which " program) t)
  (insert program)
  (next-line))
#+end_src
*** auto-insert
it is hard to correct insert without lookahead, like we shouldnt call auto-insert when handle like '#' appears in string
*** electric-operator
#+begin_src emacs-lisp
;; (use-package electric-operator)

;; (dolist (hook '(prog-mode-hook
;;                 shell-mode-hook))
;;   (add-hook hook
;;             #'(lambda ()
;;                 (unless (derived-mode-p
;;                          'lisp-mode
;;                          'emacs-lisp-mode)
;;                   (electric-operator-mode 1)))))


#+end_src
*** dogears
#+begin_src emacs-lisp
(use-package dogears
  :bind (:map global-map
              ("M-g M-k" . dogears-back)
              ("M-g M-j" . dogears-forward)))
(dogears-mode)
(setq dogears-idle 1)
#+end_src
** tools
*** consult
#+begin_src emacs-lisp
(global-unset-key "\C-s")
(use-package consult
  :bind (
         ([remap repeat-complex-command] . consult-complex-command)
         ([remap switch-to-buffer] . consult-buffer)
         ([remap switch-to-buffer-other-window] . consult-buffer-other-window)
         ([remap switch-to-buffer-other-frame] . consult-buffer-other-frame)
         ([remap project-switch-to-buffer] . consult-project-buffer)
         ([remap bookmark-jump] . consult-bookmark)
         ([remap goto-line] . consult-goto-line)
         ([remap imenu] . consult-imenu)
         ([remap yank-pop] . consult-yank-pop)
         ([remap Info-search] . consult-info)
         ("C-x b" . consult-buffer)
         ("C-x 4b" . consult-buffer-other-window)
         ("C-s r" . wrapper/consult-ripgrep)
         ("C-s l" . consult-line)
         ("C-s u" . consult-focus-lines)
         ("C-s i" . consult-imenu)
         ("C-s x" . consult-recent-xref)
         ("M-g g" . consult-goto-line)
         ("M-g o" . consult-outline)
         ("M-y" . consult-yank-pop)
         )
  :hook (completion-list-mode . consult-preview-at-point-mode)
  :init
  ;; (setq-default consult-preview-key "<f2>")
  (setq consult-async-refresh-delay 0.01)
  (setq register-preview-delay 0.01
        register-preview-function #'consult-register-format)
  (advice-add #'register-preview :override #'consult-register-window)
  :custom
  (consult-async-min-input 2)
  (consult-async-refresh-delay 0.01)
  (consult-async-input-throttle 0.2)
  (consult-async-input-debounce 0.1)
  )

(defun wrapper/consult-ripgrep (&optional dir given-initial)
  "Pass the region to consult-ripgrep if available.

DIR and GIVEN-INITIAL match the method signature of `consult-wrapper'."
  (interactive "P")
  (let ((initial
         (or given-initial
             (when (use-region-p)
               (buffer-substring-no-properties (region-beginning) (region-end))))))
    (consult-ripgrep dir initial)))

;; TODO: dwim, save name for 1min, or use last name as default; and save jump point, next invoke should start after last invoke's point, to avoid jumping to same word if user have made modifications.
(defun tu10ng/search-and-jump-next (name)
  (interactive "sname: ")
  (let ((point (re-search-forward name nil t)))
    (goto-char point)))
(global-set-key (kbd "C-s n") #'tu10ng/search-and-jump-next)

(defvar consult--xref-history nil
  "History for the `consult-recent-xref' results.")

(defun consult-recent-xref (&optional markers)
  "Jump to a marker in MARKERS list (defaults to `xref--history'.

The command supports preview of the currently selected marker position.
The symbol at point is added to the future history."
  (interactive)
  (consult--read
   (consult--global-mark-candidates
    (or markers (flatten-list xref--history)))
   :prompt "Go to Xref: "
   :annotate (consult--line-prefix)
   :category 'consult-location
   :sort nil
   :require-match t
   :lookup #'consult--lookup-location
   :history '(:input consult--xref-history)
   :add-history (thing-at-point 'symbol)
   :state (consult--jump-state)))

(defun consult-delete-default-contents ()
  (remove-hook 'pre-command-hook 'consult-delete-default-contents)
  (cond ((member this-command '(self-insert-command))
         (delete-minibuffer-contents))
        (t (put-text-property (minibuffer-prompt-end) (point-max) 'face 'default))))

(consult-customize consult-line
                   :initial (when-let ((string (thing-at-point 'symbol)))
                              (add-hook 'pre-command-hook 'consult-delete-default-contents)
                              (propertize string 'face 'shadow)))
#+end_src
consult-dir
remap M-; in vertico-map to find and insert directory into minibuffer prompt
#+begin_src emacs-lisp
(use-package consult-dir
  :bind (("C-x C-d" . consult-dir)
         :map vertico-map
         ("M-;" . consult-dir)))


#+end_src
*** eros
TODO: can eros's overlay stay if its not covering the cursor?
#+begin_src emacs-lisp
(use-package eros)
(eros-mode 1)
(setq eros-eval-result-prefix "⟹ ") ; default =>
#+end_src
*** magit
#+begin_src emacs-lisp
(use-package magit)
(setq magit-commit-ask-to-stage nil
      magit-save-repository-buffers 'dontask)
(add-to-list 'magit-no-confirm 'stage-all-changes)
#+end_src
**** show git log in commit buffer to help writing commit
#+begin_src emacs-lisp
;; show last 10 commit message
(defun tu10ng/git-commit-setup ()
  (dolist (line (seq-take
                 (magit-git-lines "log" "--pretty=%B")
                 10))
    (let ((line (concat "# " line "\n")))
      (insert line))))

(add-hook 'git-commit-setup-hook #'tu10ng/git-commit-setup)


#+end_src
**** setup gitignore conf
#+begin_src emacs-lisp
(use-package conf-mode
  :ensure nil
  :mode (("\\.gitignore\\'"     . conf-unix-mode)
         ("\\.gitconfig\\'"     . conf-unix-mode)
         ("\\.gitattributes\\'" . conf-unix-mode)))
#+end_src
**** magit todos
#+begin_src emacs-lisp
(cond
 (IS-WINDOWS ())
 (IS-LINUX
  (use-package magit-todos)
  (setq magit-todos-auto-group-items 3)
  (magit-todos-mode)))


#+end_src
**** git-add-commit-push
#+begin_src emacs-lisp
(defun aborn/magit-instant-commit ()
  "instantly commit, commit message contain current time."
  (interactive)
  (magit-diff-unstaged)
  (magit-stage-modified)
  (magit-diff-staged)
  (let ((msg (concat "commit by "
                     (user-full-name)
                     (format
                      " in %s"
                      (message (symbol-name system-type)))
                     (format-time-string
                      "@%Y-%m-%d %H:%M:%S"
                      (current-time)))))
    (magit-call-git "commit" "-m" msg))
  (magit-refresh)
  (magit-mode-bury-buffer))

(transient-append-suffix 'magit-commit "c"
  '("i" "instant" aborn/magit-instant-commit))
#+end_src
**** count line of code
#+begin_src emacs-lisp
(defun cloc-magit-root ()
  "Run Count Line Of Code for current Git repo."
  (interactive)
  (k-run-helper-command (concat "cloc " (magit-toplevel)) "*cloc*"))

#+end_src
**** smerge
#+begin_src emacs-lisp
(use-package smerge-mode
  :ensure nil
  :bind (:map smerge-mode-map
              ("M-n" . smerge-next)
              ("M-p" . smerge-prev)
              ("C-c")
              ("C-c C-c" . smerge-keep-current)))

#+end_src
*** pyim
#+begin_src elisp
(use-package pyim)
(pyim-default-scheme 'quanpin)
(setq pyim-page-length 7)
(setq pyim-process-async-delay 0.1
      pyim-process-run-delay 0.1)
(setq pyim-indicator-list nil)
(setq pyim-punctuation-dict nil)        ;disable chinese punctuation.

(use-package pyim-basedict)
(pyim-basedict-enable)

(setq default-input-method "pyim")
;; slow down pyim init speed.
(add-to-list 'load-path "~/.emacs.d/site-lisp/pyim-tsinghua-dict")

(cond
 (IS-WINDOWS ())
 (IS-LINUX
  (require 'pyim-tsinghua-dict)
  (pyim-tsinghua-dict-enable)))

(require 'pyim-cstring-utils)

(defun my-orderless-regexp (orig-func component)
  (let ((result (funcall orig-func component)))
    (pyim-cregexp-build result)))

(advice-add 'orderless-regexp :around #'my-orderless-regexp)
#+end_src
*** flymake
#+begin_src emacs-lisp
(global-set-key (kbd "M-g p") #'flymake-goto-prev-error)
(global-set-key (kbd "M-g M-p") #'flymake-goto-prev-error)
(global-set-key (kbd "M-g n") #'flymake-goto-next-error)
(global-set-key (kbd "M-g M-n") #'flymake-goto-next-error)

;; TODO: no help, maybe because when corfu selection is active, flymake will not check
(setq flymake-no-changes-timeout 0.1)

(use-package flymake
  :ensure nil
  ;; :hook (prog-mode . flymake-mode)
  :hook (flymake-mode . (lambda ()
                          (setq eldoc-documentation-functions
                                (cons 'flymake-eldoc-function
                                      (delq 'flymake-eldoc-function
                                            eldoc-documentation-functions)))))
  :init (setq elisp-flymake-byte-compile-load-path (cons "./" load-path)))

#+end_src
*** dictionary
#+begin_src emacs-lisp
(use-package popup)

;; (use-package youdao-dictionary
;;   :bind (("M-s" . youdao-dictionary-search-at-point+)))

#+end_src
*** tldr
#+begin_src emacs-lisp
(use-package tldr
  :bind ("C-c t" . tldr))

#+end_src
*** devdocs
#+begin_src emacs-lisp
(use-package devdocs
  :bind ("C-c b" . devdocs-lookup))

#+end_src
*** pdf-tools / doc-view
#+begin_src emacs-lisp
;; (add-hook 'doc-view-mode-hook #'(lambda ()
;;                                   (run-with-timer
;;                                    0.1 nil
;;                                    #'doc-view-fit-page-to-window)))
;; (setq doc-view-continuous t)

;; (use-package pdf-tools
;;   :mode ("\\.pdf\\'" . pdf-view-mode)
;;   :config
;;   (pdf-tools-install)

;;   (use-package pdf-continuous-scroll-mode
;;     :disabled                           ; This mode barely does anything useful
;;     :quelpa (pdf-continuous-scroll-mode :fetcher github :repo "dalanicolai/pdf-continuous-scroll-mode.el")
;;     :hook (pdf-view-mode . pdf-continuous-scroll-mode)))

#+end_src
** visuals
*** info colors, helpful
#+begin_src emacs-lisp
(use-package info-colors)
(add-hook 'Info-selection-hook 'info-colors-fontify-node)

(use-package helpful
  :bind
  ([remap describe-function] . helpful-callable)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key] . helpful-key))
#+end_src
*** paren
#+begin_src emacs-lisp
(use-package paren
  :hook (after-init . show-paren-mode)
  :init (setq show-paren-when-point-inside-paren t
              show-paren-when-point-in-periphery t
              show-paren-highlight-openparen t
              show-paren-delay 0.01
              rainbow-delimiters-max-face-count 6))

(use-package rainbow-delimiters
  :config
  (set-face-foreground 'rainbow-delimiters-depth-1-face "gold")
  (set-face-foreground 'rainbow-delimiters-depth-2-face "DodgerBlue1")
  (set-face-foreground 'rainbow-delimiters-depth-3-face "lime green")
  (set-face-foreground 'rainbow-delimiters-depth-4-face "gold")
  (set-face-foreground 'rainbow-delimiters-depth-5-face "DodgerBlue1")
  (set-face-foreground 'rainbow-delimiters-depth-6-face "lime green")
  (set-face-foreground 'rainbow-delimiters-depth-7-face "gold")
  (set-face-foreground 'rainbow-delimiters-depth-8-face "DodgerBlue1")
  (set-face-foreground 'rainbow-delimiters-depth-9-face "lime green")

  (set-face-attribute 'rainbow-delimiters-depth-1-face nil :weight 'ultra-heavy)
  (set-face-attribute 'rainbow-delimiters-depth-2-face nil :weight 'ultra-heavy)
  (set-face-attribute 'rainbow-delimiters-depth-3-face nil :weight 'ultra-heavy)
  (set-face-attribute 'rainbow-delimiters-depth-4-face nil :weight 'thin)
  (set-face-attribute 'rainbow-delimiters-depth-5-face nil :weight 'thin)
  (set-face-attribute 'rainbow-delimiters-depth-6-face nil :weight 'thin)
  (set-face-attribute 'rainbow-delimiters-depth-7-face nil :weight 'ultra-heavy)
  (set-face-attribute 'rainbow-delimiters-depth-8-face nil :weight 'ultra-heavy)
  (set-face-attribute 'rainbow-delimiters-depth-8-face nil :weight 'ultra-heavy)
  :hook
  ((prog-mode . rainbow-delimiters-mode)
   (shell-mode . rainbow-delimiters-mode)
   ;;(text-mode . rainbow-delimiters-mode)
   ))
#+end_src
*** pretty symbol characters
#+begin_src emacs-lisp
(use-package prettify-greek)
(use-package prettify-math)

(setq-default
 prettify-symbols-alist
 prettify-greek-lower)

(dolist (hook '(prog-mode-hook
                shell-mode-hook
                text-mode-hook))
  (add-hook hook
            #'(lambda ()
                (prettify-symbols-mode 1))
            100))

#+end_src
*** page-break-lines
bug with `visula-line-mode', maybe use truncate-line, but truncate-line is ugly
#+begin_src emacs-lisp
;; (add-to-list 'load-path "~/.emacs.d/site-lisp/page-break-lines/")
;; (require 'page-break-lines)
;; (use-package page-break-lines)
;; (setq page-break-lines-modes '(prog-mode
;;                                shell-mode
;;                                text-mode))
;; (dolist (hook '(prog-mode-hook
;;                 shell-mode-hook
;;                 text-mode-hook))
;;   (add-hook hook #'(lambda ()
;;                      (page-break-lines-mode))))

;; (global-page-break-lines-mode)

(use-package form-feed-st)
(global-form-feed-st-mode)

#+end_src
*** image scroll
#+begin_src emacs-lisp
;; (use-package iscroll)
;; (add-hook 'text-mode-hook #'iscroll-mode)
#+end_src
*** rainbow-mode
#+begin_src emacs-lisp
(use-package rainbow-mode)

(setq rainbow-x-colors t)
(define-globalized-minor-mode global-rainbow-mode rainbow-mode (lambda () (rainbow-mode 1)))
#+end_src
*** sideline
#+begin_src emacs-lisp
(use-package sideline)

(setq sideline-delay 0.3)
(global-sideline-mode)

(use-package sideline-eldoc
  :after sideline
  :load-path "c:/Users/incubator/Projects/sideline-eldoc/"
  :ensure nil)

(setq sideline-eldoc-documentation nil)
(setq sideline-backends-right '(sideline-eldoc))

(defun sideline-eldoc--display (callback &rest _)
  "Execute CALLBACK to display with sideline.

Also display in minibuffer, causing cursor to extend very long("
  (when eldoc-mode
    (unless (and (minibufferp)
                 sideline-eldoc-hide-minibuffer)
      (when-let ((msg sideline-eldoc--message))
        (funcall callback (sideline-eldoc--combine-all-infomations))))))

(defun sideline-eldoc--extract-message (format-string &rest args)
  "Extract eldoc message format FORMAT-STRING with ARGS."
  (if (or (bound-and-true-p edebug-mode) (minibufferp))
      (progn
        (add-hook 'post-command-hook #'eldoc-minibuffer--cleanup)
	    (with-current-buffer
	        (window-buffer
	         (or (window-in-direction 'above (minibuffer-window))
		         (minibuffer-selected-window)
		         (get-largest-window)))
          (when (and mode-line-format
                     (not (and (listp mode-line-format)
                               (assq 'eldoc-mode-line-string mode-line-format))))
	        (setq mode-line-format
                  (funcall
                   (if (listp mode-line-format) #'append #'list)
                   (list "" '(eldoc-mode-line-string
			                  (" " eldoc-mode-line-string " ")))
                   mode-line-format)))
          (setq eldoc-mode-line-string
                (when (stringp format-string)
                  (apply #'format-message format-string args)))
          (force-mode-line-update)))
    (if format-string
        (setq-local sideline-eldoc--message (apply #'format format-string args))
      (setq-local sideline-eldoc--message nil))))

#+end_src
** frivolities
*** selectric
Every so often, you want everyone else to /know/ that you're typing, or just to
amuse oneself. Introducing: typewriter sounds!
#+begin_src emacs-lisp
(use-package selectric-mode)

#+end_src
*** wakatime
#+begin_src emacs-lisp
(use-package wakatime-mode)
(setq wakatime-disable-on-error t)
(setq wakatime-cli-path "wakatime-cli")
(global-wakatime-mode 1)

(defun wakatime-save ()
  "Send save notice to WakaTime."
  (when (buffer-file-name (current-buffer))
    (unless (file-remote-p default-directory)
      (wakatime-call t))))

(defun wakatime-ping ()
  "Send ping notice to WakaTime."
  (when (buffer-file-name (current-buffer))
    (unless (file-remote-p default-directory)
      (wakatime-call nil))))

#+end_src
*** rgb cursor
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/site-lisp/rgb-cursor/")
(require 'rgb-cursor)
(rgb-cursor-mode 1)
#+end_src
*** typing game
speed-type
#+begin_src emacs-lisp
(use-package speed-type)

(setq speed-type-min-chars 1000)

(defun tu10ng/speed-type-buffer (full)
  (interactive "P")
  (if (or full
          (< (buffer-size) speed-type-min-chars))
      (speed-type-region (point-min) (point-max))
    (let* ((buf (current-buffer))
           (start (save-excursion
                    (goto-char (random (- (point-max) speed-type-min-chars)))
                    (beginning-of-line)
                    (point)))
           (end (save-excursion
                  (goto-char (+ start speed-type-min-chars))
                  (beginning-of-line)
                  (point))))
      (speed-type-region start end))))

(defun random-alpha ()
  (let* ((alpha "abcdefghijklmnopqrstuvwxyz")
         (i (random (length alpha))))
    (string (elt alpha i))))

(defun tu10ng/speed-type-random ()
  (interactive)
  (let* ((alpha-num 2000)
         (spc-num (/ alpha-num 12)))
    (with-current-buffer (get-buffer-create "*speed-type-random*")
      (erase-buffer)
      (dotimes (_ alpha-num)
        (insert (random-alpha)))
      (dotimes (_ spc-num)
        (goto-char (random (point-max)))
        (insert " "))
      (fill-region (point-min) (point-max))
      (tu10ng/speed-type-buffer t))))


#+end_src
*** try
#+begin_src emacs-lisp
(use-package try)
#+end_src
*** screenshot
git@github.com:tecosaur/screenshot.git
#+begin_src emacs-lisp
;; (use-package posframe)
;; (add-to-list 'load-path "~/.emacs.d/site-lisp/screenshot/")
;; (require 'screenshot)
#+end_src
*** bmi
#+begin_src emacs-lisp
(defun bmi-kilos-meters (weight height)
  "Calculate body mass index from WEIGHT kilograms and HEIGHT meters."
  (interactive "nKilograms:\nnMeters:")
  ;; Convert integers to float for type coercion.
  (bmi-message (/ (float weight) (* height height))))

(defun bmi-kilos-centimeters (weight height)
  "Calculate body mass index from WEIGHT kilograms and HEIGHT centimeters."
  (interactive "nKilograms:\nnCentimeters:")
  ;; Convert integers to float for type coercion.
  (bmi-kilos-meters weight (/ (float height) 100)))

(defun bmi-message (bmi-number)
  "Return body mass index message for BMI-NUMBER."
  (let ((bmi-status (cond
                     ((> bmi-number 23.9) '("Overweight" 23.9))
                     ((> bmi-number 18.5) '("Normal" 18.5))
                     (t "obese"))))
    (message
     (format "Body mass index (BMI): %.1f >  %.1f (\"%s\")"
             bmi-number (cadr bmi-status) (car bmi-status)))
    ;; Return `bmi-number' as function's return value.
    bmi-number))
#+end_src
** file types
#+begin_src emacs-lisp
(tu10ng/use-package-multi
 systemd
 ebnf-mode
 lox-mode
 graphviz-dot-mode
 groovy-mode
 yaml-mode
 typescript-mode
 cmake-mode
 lua-mode
 powershell
 json-mode
 ripgrep
 fish-mode
 )

#+end_src
* package/mode confguration
** org mode
*** system wide config
**** git diff
Protesilaos wrote a [[https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/][very helpful article]] in which he explains how to change the
git diff chunk heading to something more useful than just the immediate line
above the hunk --- like the parent heading.

This can be achieved by first adding a new diff mode to git in =~/.config/git/attributes=
#+begin_src fundamental
,*.org   diff=org
#+end_src

Then adding a regex for it to =~/.config/git/config=
#+begin_src gitconfig
[diff "org"]
  xfuncname = "^(\\*+ +.*)$"
#+end_src
*** better default
#+begin_src emacs-lisp
(setq org-cycle-separator-lines -1
      org-use-fast-todo-selection 'expert
      org-log-into-drawer t
      org-startup-folded t
      org-emphasis-alist nil
      org-return-follows-link nil
      org-hide-emphasis-markers nil
      org-imenu-depth 5
      org-use-speed-commands t
      org-insert-heading-respect-content t)

(global-set-key "\C-cl" #'org-store-link)
(global-set-key "\C-ca" (lambda () (interactive) (org-agenda nil "n")))
;; (global-set-key "\C-cc" #'org-capture)
(global-set-key "\C-cc" (lambda () (interactive) (org-capture 4 "g")))

(defun tu10ng/org-metaup ()
  (interactive)
  (condition-case e
      (org-metaup)
    (error
     (move-text-up 0 (line-end-position) 1))))

(defun tu10ng/org-metadown ()
  (interactive)
  (condition-case e
      (org-metadown)
    (error
     (move-text-down 0 (line-end-position) 1))))    

(define-key org-mode-map [M-down] #'tu10ng/org-metadown)
(define-key org-mode-map [M-up] #'tu10ng/org-metaup)
(define-key org-mode-map (kbd "C-M-k") #'org-cut-subtree)
(define-key org-mode-map (kbd "C-<return>") (lambda ()
                                              (interactive)
                                              (org-insert-heading nil t 1)))

(use-package htmlize)
#+end_src
*** actions
**** defaults
#+begin_src emacs-lisp
(setq org-directory "~/org"
      org-use-property-inheritance t
      ;; org-log-done 'time
      org-list-allow-alphabetical t
      org-catch-invisible-edits 'smart
      org-image-actual-width '(0.8)
      org-footnote-auto-adjust t)

(require 'org-tempo)
#+end_src
**** List bullet sequence
I think it makes sense to have list bullets change with depth
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+") ("1." . "a.")))
#+end_src
**** agenda
#+begin_src emacs-lisp
(setq org-agenda-span 14
      org-agenda-restore-windows-after-quit t
      org-agenda-files '("~/org/gtd.org")
      org-agenda-todo-ignore-deadlines t
      org-agenda-prefix-format '((agenda  . "  • %?-12t% s")
                                 (todo . " %i %-12:c")
                                 (tags . " %i %-12:c")
                                 (search . " %i %-12:c"))
      org-agenda-window-setup 'other-window
      )

(add-hook 'org-agenda-mode-hook #'hl-line-mode)
#+end_src
**** src
#+begin_src emacs-lisp
(setq org-src-window-setup 'split-window-below)

#+end_src
**** capture
***** doct (declarative org capture templates)
#+begin_src emacs-lisp
(use-package doct)

(setq org-capture-templates
      (doct '(("gtd"
               :keys "g"
               :file "~/org/gtd.org"
               :prepend t
               :immediate-finish t
               :template ("* %^{gtd?}")))))
#+end_src
**** babel
#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "output replace")
        (:exports . "code")
        (:cache . "no")
        (:noweb . "no")
        (:hlines . "no")
        (:tangle . "no")))

(org-babel-do-load-languages 'org-babel-load-languages
			                 '((emacs-lisp . t)
                               (dot . t)))
#+end_src
***** org tempo
#+begin_src emacs-lisp
(add-to-list 'org-structure-template-alist '("se" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("sb" . "src bash"))
(add-to-list 'org-structure-template-alist '("sp" . "src powershell"))

;;(setf (cdr (assoc "e" org-structure-template-alist)) "src emacs-lisp")
#+end_src
**** refile
#+begin_src emacs-lisp
(use-package org-refile
  :ensure nil
  :after org
  :custom
  (org-refile-targets '((nil :maxlevel . 5) (org-agenda-files :maxlevel . 5)))
  (org-refile-use-outline-path t)
  (org-outline-path-complete-in-steps nil)
  (org-refile-allow-creating-parent-nodes 'confirm))
#+end_src
**** insert image
#+begin_src emacs-lisp
(defun org-insert-image-from-clipboard ()
  "Insert an image from the clipboard into the current org buffer."
  (interactive)
  (let* ((current-dir (file-name-directory buffer-file-name))
         (file-name-base (file-name-base buffer-file-name))
         (attach-dir (concat current-dir "attach/" file-name-base "/"))
         (image-file (concat attach-dir (format-time-string "%Y%m%d_%H%M%S") ".png")))
    ;; Ensure attach directory exists
    (unless (file-exists-p attach-dir)
      (make-directory attach-dir t))
    ;; Save the clipboard image to the attach directory
    (if (eq system-type 'windows-nt)
        (shell-command (concat "powershell -command \"Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.Clipboard]::GetImage().Save('" image-file "', [System.Drawing.Imaging.ImageFormat]::Png)\""))
      (error "Unsupported OS"))
    ;; Insert the link to the image in the org file
    (insert (concat "[[file:" image-file "]]"))
    (org-display-inline-images)))

#+end_src
*** visuals
**** org modern indent
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/site-lisp/org-modern-indent/")
(require 'org-modern-indent)
(add-hook 'org-indent-mode-hook #'org-modern-indent-mode)

#+end_src
**** org table
Use [[https://github.com/casouri/valign][valign]] for tables alignments.
#+begin_src emacs-lisp
;; (use-package valign
;;   :hook
;;   (org-mode . valign-mode)
;;   (markdown-mode . valign-mode)
;;   :config
;;   (setq valign-fancy-bar 1)
;;   )
#+end_src
**** font display

#+begin_src emacs-lisp
(setq org-edit-src-content-indentation 0)
(setq org-startup-indented t)
#+end_src
It seems reasonable to have deadlines in the error face when they're passed.
#+begin_src emacs-lisp
(setq org-agenda-deadline-faces
      '((1.01 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src
We can then have quote blocks stand out a bit more by making them /italic/.
#+begin_src emacs-lisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

Org files can be rather nice to look at, particularly with some of the
customisations here. This comes at a cost however, expensive font-lock.
Feeling like you're typing through molasses in large files is no fun, but there
is a way I can defer font-locking when typing to make the experience more
responsive.
#+begin_src emacs-lisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  (when (> (buffer-size) 200000)
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1
                org-indent-mode nil)))

(add-hook 'org-mode-hook #'locally-defer-font-lock)
#+end_src
Apparently this causes issues with some people, but I haven't noticed anything
problematic beyond the expected slight delay in some fontification, so until I
do I'll use the above.
**** symbols
symbol prettify is set [[*pretty symbol characters][pretty symbol characters]] 
#+begin_src emacs-lisp
(setq org-ellipsis " ▾ "
      org-hide-leading-stars nil)

(setq org-prettify-symbols-alist
      (append
       prettify-symbols-alist
       '(("#+BEGIN_SRC" . "✎")
         ("#+END_SRC" . "□")
         ("#+begin_src" . "✎")
         ("#+end_src" . "□")
         ("#+RESULTS:" . "⟾")
         ("[ ]" . "☐")
         ("[-]" . "🝕")
         ("[X]" . "🗹")
         ("#+begin_quote" . "»")
         ("#+end_quote" . "□")
         ("#+begin_verse" . "ζ")
         ("#+end_verse" . "□")
         ("#+begin_example" . "⟝")
         ("#+end_example" . "□")
         ("#+begin_export" . "🙵")
         ("#+end_export" . "□")
         ("#+END:" . "□")
         ("#+BEGIN:" . "✎")
         ("#+CAPTION:" . "✑")
         ("#+ATTR_LATEX" . "🄛"))))

(add-hook 'org-mode-hook
          #'(lambda ()
              (setq-local prettify-symbols-alist
                          org-prettify-symbols-alist)
              (prettify-symbols-mode 1)))

#+end_src
**** org-appear
#+begin_src emacs-lisp
(use-package org-appear)
(add-hook 'org-mode-hook #'org-appear-mode)
(setq org-appear-autolinks t
      org-appear-delay 0.5)
#+end_src
**** dont delete trailing whitespace on headline
#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'(lambda () (electric-indent-local-mode -1)))

(define-key org-mode-map (kbd "RET")
            #'(lambda (&optional arg interactive)
                (interactive "P\np")
                (org-return t arg interactive)))

(defun org-newline-and-indent (&optional arg)
  "like `newline-and-indent' except this function dont `delete-horizontal-space'"
  (interactive "*p")
  (unless arg
    (setq arg 1))
  (let ((electric-indent-mode nil))
    (dotimes (_ arg)
      (newline nil t)
      (indent-according-to-mode))))

#+end_src

**** latex fragments
from vitalyankh
***** highlighting
#+begin_src emacs-lisp
(require 'org-src)
(add-to-list 'org-src-block-faces
             '("latex" (:inherit default :extend t)))
#+end_src
***** render
**** inline pictures
#+begin_src emacs-lisp
(setq org-startup-with-inline-images t)
(setq org-image-actual-width '(200))
#+end_src
*** exporting
**** general settings
#+begin_src emacs-lisp
(setq org-export-async-debug t)
(setq org-export-in-background nil
      org-use-sub-superscripts '{}
      org-export-allow-bind-keywords t
      org-export-with-sub-superscripts nil)
#+end_src
**** LaTeX export
from vitalyankh
#+begin_quote
While the ~-%latex~ above is slightly hacky (~-pdflatex~ expects to be given a
value) it allows us to leave ~org-latex-compilers~ unmodified.
This is nice in case I open an org file that uses =#+LATEX_COMPILER= for example,
it should still work.
#+end_quote
#+begin_src emacs-lisp
(require 'ox-latex)

(setq org-latex-pdf-process '("latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
(setq org-latex-compiler "xelatex")

;; (setq org-latex-pdf-process
;;       '("xelatex -interaction nonstopmode -output-directory %o %f"
;;         "xelatex -interaction nonstopmode -output-directory %o %f"
;;         "xelatex -interaction nonstopmode -output-directory %o %f"))
;; (setq org-latex-pdf-process '("xelatex -interaction nonstopmode %f"
;;                               "xelatex -interaction nonstopmode %f"))
;; (setq org-latex-default-packages-alist
;;       (remove '("AUTO" "inputenc" t) org-latex-default-packages-alist))

(add-to-list 'org-latex-classes
	         '("ctexart"
	           "\\documentclass[UTF8,a4paper]{ctexart}"
	           ;;"\\documentclass[fontset=none,UTF8,a4paper,zihao=-4]{ctexart}"
	           ("\\section{%s}" . "\\section*{%s}")
	           ("\\subsection{%s}" . "\\subsection*{%s}")
	           ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
	           ("\\paragraph{%s}" . "\\paragraph*{%s}")
	           ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
	           )
	         )

(add-to-list 'org-latex-classes
	         '("ctexbook"
		       "\\documentclass[UTF8,a4paper]{ctexbook}"
		       ;;("\\part{%s}" . "\\part*{%s}")
		       ("\\chapter{%s}" . "\\chapter*{%s}")
		       ("\\section{%s}" . "\\section*{%s}")
		       ("\\subsection{%s}" . "\\subsection*{%s}")
	           ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
	           )
	         )

(add-to-list 'org-latex-classes
	         '("beamer"
		       "\\documentclass{beamer}
               \\usepackage[fontset=none,UTF8,a4paper,zihao=-4]{ctex}"
	           org-beamer-sectioning)
	         )

(setq org-latex-default-class "ctexart")


#+end_src
***** Nicer checkboxes

We'll assume that thanks to the clever preamble the various custom =\checkbox...=
commands below are defined.

#+begin_src emacs-lisp
(defun +org-export-latex-fancy-item-checkboxes (text backend info)
  (when (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string
     "\\\\item\\[{$\\\\\\(\\w+\\)$}\\]"
     (lambda (fullmatch)
       (concat "\\\\item[" (pcase (substring fullmatch 9 -3) ; content of capture group
                             ("square"   "\\\\checkboxUnchecked")
                             ("boxminus" "\\\\checkboxTransitive")
                             ("boxtimes" "\\\\checkboxChecked")
                             (_ (substring fullmatch 9 -3))) "]"))
     text)))

;; TODO Symbol's value as variable is void: org-export-filter-item-functions
(add-to-list 'org-export-filter-item-functions
             '+org-export-latex-fancy-item-checkboxes)
#+end_src
***** extra special strings
#+begin_quote
LaTeX already recognises =---= and =--= as em/en-dashes, =\-= as a shy hyphen, and the
conversion of =...= to =\ldots{}= is hardcoded into ~org-latex-plain-text~ (unlike
~org-html-plain-text~).

I'd quite like to also recognise =->= and =<-=, so let's set come up with some advice.

#+end_quote

#+begin_src emacs-lisp
(defvar org-latex-extra-special-string-regexps
  '(("<->" . "\\\\(\\\\leftrightarrow{}\\\\)")
    ("->" . "\\\\textrightarrow{}")
    ("<-" . "\\\\textleftarrow{}")))

(defun org-latex-convert-extra-special-strings (string)
  "Convert special characters in STRING to LaTeX."
  (dolist (a org-latex-extra-special-string-regexps string)
    (let ((re (car a))
          (rpl (cdr a)))
      (setq string (replace-regexp-in-string re rpl string t)))))

(defadvice! org-latex-plain-text-extra-special-a (orig-fn text info)
  "Make `org-latex-plain-text' handle some extra special strings."
  :around #'org-latex-plain-text
  (let ((output (funcall orig-fn text info)))
    (when (plist-get info :with-special-strings)
      (setq output (org-latex-convert-extra-special-strings output)))
    output))

#+end_src
***** mathjax
theres already a default value
#+begin_src emacs-lisp
;; (setq org-html-mathjax-options
;;       '((path "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")
;; 	(scale "100")
;; 	(align "center")
;; 	(indent "2em")
;; 	(mathml nil)))

;; (setq org-html-mathjax-template
;;       "<script type=\"text/javascript\" src=\"%PATH\"></script>")
#+end_src
**** html
#+begin_src emacs-lisp
(defun replace-in-string (what with in)
  (replace-regexp-in-string (regexp-quote what) with in nil 'literal))

(defun org-html--format-image (source attributes info)
  (progn
    (setq source (replace-in-string "%20" " " source))
    (format "<img src=\"data:image/%s;base64,%s\"%s />"
            (or (file-name-extension source) "")
            (base64-encode-string
             (with-temp-buffer
               (insert-file-contents-literally source)
               (buffer-string)))
            (file-name-nondirectory source))
    ))

(defun replace-prefix-if-present (string prefix new-prefix)
  "If STRING starts with PREFIX, replace the PREFIX by NEW-PREFIX.
   Else, returns NIL."
  (if (string-prefix-p prefix string)
      (concat new-prefix (substring string (length prefix)))
    string))

(defun org-org-html--format-image (source attributes info)
  (format "<img src=\"data:image/%s+xml;base64,%s\"%s />"
          (or (file-name-extension source) "")
          (base64-encode-string
           (with-temp-buffer
             (insert-file-contents-literally (replace-prefix-if-present source "file:///" ""))
             (buffer-string)))
          (file-name-nondirectory source)))
(advice-add #'org-html--format-image :override #'org-org-html--format-image)

#+end_src
***** latex
**** reveal
By default reveal is rather nice, there are just a few tweaks that I consider a
good idea.
vpn may cause this fail!

#+begin_src emacs-lisp
(use-package ox-reveal)
(setq org-re-reveal-theme "white"
      org-re-reveal-transition "slide"
      ;; org-re-reveal-plugins '(markdown notes math search zoom)
      org-reveal-root "/home/qb/Downloads/reveal.js-4.4.0/") ;TODO wrong path name
#+end_src
**** gfm markdown
#+begin_src emacs-lisp
(use-package ox-gfm
  :after org
  :custom (org-export-with-toc nil))
#+end_src
** python
#+begin_src emacs-lisp
(use-package python-black)
;; wierd mode map
(define-key python-base-mode-map (kbd "C-M-\\") #'python-black-buffer)
(define-key python-ts-mode-map (kbd "C-M-\\") #'python-black-buffer)

;; (define-key python-mode-map [remap indent-buffer] #'python-black-buffer)

(setq python-indent-guess-indent-offset-verbose nil)
#+end_src
** makefile
#+begin_src emacs-lisp
(add-hook 'makefile-mode-hook #'(lambda () (fset 'makefile-warn-suspicious-lines 'ignore)))
#+end_src
** cc mode
#+begin_src emacs-lisp
(defun tu10ng/substatement-open-insert-space-before (_syntax pos)
  "like this: if (...)_{"
  (unless (char-equal (char-after (1- pos)) ?\s)
    (insert " "))
  '(after))

(c-add-style "hw"
             '((c-basic-offset . 4)     ; Guessed value
               (indent-tabs-mode . nil)
               (c-cleanup-list . (brace-else-brace
                                  brace-elseif-brace
                                  brace-catch-brace
                                  empty-defun-braces
                                  one-liner-defun
                                  defun-close-semi
                                  scope-operator
                                  compact-empty-funcall))
               (c-hanging-braces-alist . ((defun-open before after)
                                          (class-open after)
                                          (class-close before)
                                          (block-close . c-snug-do-while)
                                          (statement-cont)
                                          (substatement-open . tu10ng/substatement-open-insert-space-before)
                                          (brace-list-open)
                                          (brace-list-close)
                                          (brace-entry-open)
                                          (extern-lang-open after)
                                          (namespace-open after)
                                          (module-open after)
                                          (composition-open after)
                                          (inexpr-class-open after)
                                          (inexpr-class-close before)
                                          (arglist-cont-nonempty)))
               (c-offsets-alist
                (block-close . 0)       ; Guessed value
                (class-close . 0)       ; Guessed value
                (defun-block-intro . +) ; Guessed value
                (defun-close . 0)       ; Guessed value
                (defun-open . 0)        ; Guessed value
                (inclass . +)           ; Guessed value
                (statement . 0)             ; Guessed value
                (statement-block-intro . +) ; Guessed value
                (topmost-intro . 0)         ; Guessed value
                (access-label . -)
                (annotation-top-cont . 0)
                (annotation-var-cont . +)
                (arglist-close . c-lineup-close-paren)
                (arglist-cont c-lineup-gcc-asm-reg 0)
                (arglist-cont-nonempty . c-lineup-arglist)
                (arglist-intro . +)
                (block-open . 0)
                (brace-entry-open . 0)
                (brace-list-close . 0)
                (brace-list-entry . 0)
                (brace-list-intro . +)
                (brace-list-open . 0)
                (c . c-lineup-C-comments)
                (case-label . +)
                (catch-clause . 0)
                (class-open . 0)
                (comment-intro . c-lineup-comment)
                (composition-close . 0)
                (composition-open . 0)
                (cpp-define-intro c-lineup-cpp-define +)
                (cpp-macro . -1000)
                (cpp-macro-cont . +)
                (do-while-closure . 0)
                (else-clause . 0)
                (extern-lang-close . 0)
                (extern-lang-open . 0)
                (friend . 0)
                (func-decl-cont . +)
                (incomposition . +)
                (inexpr-class . +)
                (inexpr-statement . +)
                (inextern-lang . +)
                (inher-cont . c-lineup-multi-inher)
                (inher-intro . +)
                (inlambda . 0)
                (inline-close . 0)
                (inline-open . +)
                (inmodule . +)
                (innamespace . +)
                (knr-argdecl . 0)
                (knr-argdecl-intro . +)
                (label . 2)
                (lambda-intro-cont . +)
                (member-init-cont . c-lineup-multi-inher)
                (member-init-intro . +)
                (module-close . 0)
                (module-open . 0)
                (namespace-close . 0)
                (namespace-open . 0)
                (objc-method-args-cont . c-lineup-ObjC-method-args)
                (objc-method-call-cont c-lineup-ObjC-method-call-colons c-lineup-ObjC-method-call +)
                (objc-method-intro .
                                   [0])
                (statement-case-intro . +)
                (statement-case-open . 0)
                (statement-cont . +)
                (stream-op . c-lineup-streamop)
                (string . -1000)
                (substatement . +)
                (substatement-label . 2)
                (substatement-open . +)
                (template-args-cont c-lineup-template-args +)
                (topmost-intro-cont . c-lineup-topmost-intro-cont))))

(setq c-default-style "hw"
      c-basic-offset 4)

(add-hook 'c-mode-common-hook 'c-toggle-auto-hungry-state)
#+end_src
eglot
#+begin_src emacs-lisp
(add-to-list 'eglot-server-programs
             '(c-mode
               . ("clangd"
                  "-j=8"
                  "--log=error"
                  ;; "--malloc-trim"
                  "--background-index"
                  ;; "--clang-tidy"
                  "--completion-style=detailed"
                  "--pch-storage=memory"
                  "--header-insertion=never"
                  "--header-insertion-decorators=0")))
#+end_src
** nasm mode
#+begin_src emacs-lisp
(use-package nasm-mode)
(add-to-list 'auto-mode-alist '("\\.nasm\\'" . nasm-mode))


#+end_src
** rust mode
#+begin_src emacs-lisp
(use-package rust-mode)
(define-key rust-mode-map (kbd "C-M-\\") #'rust-format-buffer)
;; (define-key rust-ts-mode-map (kbd "C-M-\\") #'rust-format-buffer)

(defun rust-electric-semi&comma ()
  (interactive)
  (insert ";")
  (tu10ng/open-below))

(define-key rust-mode-map (kbd ";") #'rust-electric-semi&comma)
#+end_src
*** lalrpop
#+begin_src emacs-lisp
(define-derived-mode lalrpop-mode rust-mode "Lalrpop")
(add-to-list 'auto-mode-alist '("\\.lalrpop\\'" . lalrpop-mode))

#+end_src
** markdown mode
#+begin_src emacs-lisp
(use-package markdown-mode
  :mode (("\\.md\\.html\\'" . markdown-mode)
         ("README\\.md\\'" . gfm-mode)))
(setq markdown-command "marked")

#+end_src
** haskell mode
#+begin_src emacs-lisp
(use-package haskell-mode)

#+end_src
** bison
#+begin_src emacs-lisp
(use-package bison-mode)
;; (setq bison-prettify-symbols-alist
;;       (append prettify-symbols-alist
;;               '(("%%" . "%"))))
;; (add-hook 'bison-mode-hook
;;           #'(lambda ()
;;               (setq-local prettify-symbols-alist
;;                           bison-prettify-symbols-alist)))
#+end_src
** lisp
*** development
#+begin_src emacs-lisp
(define-key lisp-mode-shared-map (kbd "C-c C-p") #'eval-print-last-sexp)

(setq-default eval-expression-print-level nil
              eval-expression-print-length nil)
#+end_src
*** cl
#+begin_src emacs-lisp
(use-package slime
  :config
  (remove-hook 'lisp-mode-hook 'slime-lisp-mode-hook)

  (setq-default inferior-lisp-program "sbcl"
                slime-lisp-implementations
                `((sbcl ("sbcl" "--dynamic-space-size" "4096"))
                  (mega-sbcl ("sbcl" "--dynamic-space-size" "16384" "--control-stack-size" "2"))
                  (ccl ("ccl64"))))

  ;; Slime mode line
  (defun slime-mode-line ()
    (concat (slime-connection-name) " "
            (propertize (downcase (string-trim (slime-current-package) "#?:\\|\"" "\""))
                        'face 'k-proper-name)))

  ;; Hacks to make slime-autodoc works better
  (setq eldoc-idle-delay 0)

  ;; Slime debug window non-prolifiration
  ;; (set-alist 'display-buffer-alist "\\`*sldb" '((display-buffer-reuse-mode-window)))
  )

#+end_src

#+begin_src emacs-lisp
;; (use-package slime-company
;;   :config
;;   (setq-default slime-company-completion 'fuzzy)
;;   (add-to-list 'company-backends 'company-slime)

;;   (defun company-slime (command &optional arg &rest ignored)
;;     "Company mode backend for slime."
;;     (let ((candidate (and arg (substring-no-properties arg))))
;;       (cl-case command
;;         (init
;;          (slime-company-active-p))
;;         (prefix
;;          (when (and ;; OUR CHANGE
;;                 (or (slime-company-active-p)
;;                     (k-slime-command-p current-minibuffer-command))
;;                 (slime-connected-p)
;;                 (or slime-company-complete-in-comments-and-strings
;;                     (null (slime-company--in-string-or-comment))))
;;            (company-grab-symbol)))
;;         (candidates
;;          (slime-company--fetch-candidates-async candidate))
;;         (meta
;;          (let ((*slime-company--meta-request* t))
;;            (slime-company--arglist candidate)))
;;         (annotation
;;          (concat (when slime-company-display-arglist
;;                    (slime-company--arglist-only candidate))
;;                  (when slime-company-display-flags
;;                    (concat " " (get-text-property 0 'flags arg)))))
;;         (doc-buffer
;;          (unless *slime-company--meta-request*
;;            (slime-company--doc-buffer candidate)))
;;         (quickhelp-string
;;          (unless *slime-company--meta-request*
;;            (slime-company--quickhelp-string candidate)))
;;         (location
;;          (slime-company--location candidate))
;;         (post-completion
;;          (slime-company--post-completion candidate))
;;         (sorted
;;          (eq slime-company-completion 'fuzzy))))))

;; (add-to-list 'load-path "~/.emacs.d/elpa/slime-20230222.1526/contrib/")
;; (require 'unix-in-slime "~/.quicklisp/local-projects/unix-in-lisp/unix-in-slime")

#+end_src
(use-package slime)
(setq inferior-lisp-program (executable-find "sbcl"))
(define-key slime-mode-map (kbd "C-c C-c") #'slime-eval-buffer)

#+begin_src emacs-lisp
(use-package sly)
(setq inferior-lisp-program "sbcl"
      sly-db-focus-debugger t)
(define-key sly-mode-map (kbd "C-c b") #'sly-eval-buffer)
(define-key sly-editing-mode-map (kbd "M-p") #'nil)
(define-key sly-editing-mode-map (kbd "M-n") #'nil)

;; minor fix on the format string
(defun common-lisp-glossary-6.0 (term)
  "Get a URL for a glossary term TERM."
  (let ((anchor (gethash term common-lisp-hyperspec--glossary-terms)))
    (if (not anchor)
	    (message "Unknown glossary term: %s" term)
      (format "%sBody/26_glo_%s.htm"
	          common-lisp-hyperspec-root
	          (let ((char (string-to-char term)))
		        (if (and (<= ?a char)
			             (<= char ?z))
		            (make-string 1 char)
		          "9"))
	          anchor))))

;; sly-mrepl
(add-to-list 'load-path "~/.emacs.d/elpa/sly-20230224.911/contrib/")



#+end_src
*** clojure
**** for syntax support
#+begin_src emacs-lisp
(use-package clojure-mode)

(setq clojure-toplevel-inside-comment-form t)

(with-eval-after-load "clojure-mode"
  (define-clojure-indent
   (re-frame/reg-event-fx :defn)
   (re-frame/reg-event-db :defn)
   (re-frame/reg-sub :defn)
   (re-frame/reg-fx :defn)
   (t/async :defn)
   (thrown-with-msg? :defn)))

#+end_src

#+begin_src emacs-lisp
;; (defface tu10ng/clojure-square-bracket-face
;;   '((t :foreground "red"
;;        :slant italic
;;        ))
;;   "face for square bracket because it confuses with round braces")

(add-hook 'clojure-mode-hook
          (lambda ()
            (font-lock-add-keywords nil
                                    '(("\\[" . 'italic)
                                      ("\\]" . 'italic)))))

#+end_src
**** repl connection
#+begin_src emacs-lisp
(use-package cider)

(autoload 'cider-jack-in "cider" nil t)

(setq cider-repl-wrap-history t)
(setq cider-offer-to-open-cljs-app-in-browser nil)

(define-key cider-mode-map (kbd "C-c C-c") #'cider-load-buffer)

#+end_src
***** format code
https://github.com/DogLooksGood/zprint.el
https://github.com/kkinnear/zprint
#+begin_src emacs-lisp
;; (with-eval-after-load "cider"
;;   (define-key cider-mode-map (kbd "C-c C-f") nil))



#+end_src
**** misc
#+begin_src emacs-lisp
;; (add-to-list 'auto-mode-alist '("lein-env" . enh-ruby-mode))
;; its says cider provided this
;; (use-package clojure-mode-extra-font-locking)

;; these help me out with the way I usually develop web apps
;; (defun cider-start-http-server ()
;;   (interactive)
;;   (cider-load-current-buffer)
;;   (let ((ns (cider-current-ns)))
;;     (cider-repl-set-ns ns)
;;     (cider-interactive-eval (format "(println '(def server (%s/start))) (println 'server)" ns))
;;     (cider-interactive-eval (format "(def server (%s/start)) (println server)" ns))))

;; (defun cider-refresh ()
;;   (interactive)
;;   (cider-interactive-eval (format "(user/reset)")))

;; (defun cider-user-ns ()
;;   (interactive)
;;   (cider-repl-set-ns "user"))

;; (eval-after-load 'cider
;;   '(progn
;;      (define-key clojure-mode-map (kbd "C-c C-v") 'cider-start-http-server)
;;      (define-key clojure-mode-map (kbd "C-M-r") 'cider-refresh)
;;      (define-key clojure-mode-map (kbd "C-c u") 'cider-user-ns)
;;      (define-key cider-mode-map (kbd "C-c u") 'cider-user-ns)))

#+end_src
*** racket
#+begin_src emacs-lisp
(use-package racket-mode)
(require 'racket-xp)
(add-hook 'racket-mode-hook #'racket-xp-mode)
#+end_src
*** scheme
#+begin_src emacs-lisp
(use-package scheme)

(use-package geiser
  :config
  (defun geiser-mode-maybe ()
    (unless (eq major-mode 'scheme-interaction-mode)
      (geiser-mode)))
  (add-hook 'scheme-mode-hook 'geiser-mode-maybe)
  (setq geiser-mode-start-repl-p t))

#+end_src
** thought-manage
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/site-lisp/thought-manage/")
(require 'thought-manage)
(setq thought-manage-disable-auto-remove-blank-line t)
#+end_src
** llvm mode
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/site-lisp/llvm-utils/")
(require 'llvm-mode)

#+end_src
** ocaml
#+begin_src emacs-lisp
(use-package tuareg)

#+end_src
** latex
#+begin_src emacs-lisp
(use-package tex
  :ensure auctex
  :mode (("\\.tex\\'" . LaTeX-mode))
  :config
  (setq-default TeX-engine 'xetex)
  (add-hook 'LaTeX-mode-hook
            #'(lambda ()
                (setq fill-column 80)
                (setq TeX-master t)))

  (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
        TeX-view-program-list '(("PDF Tools" TeX-pdf-tools-sync-view))
        TeX-source-correlate-start-server t)

  (setq TeX-auto-save t
        TeX-parse-self t
        TeX-save-query nil)

  (add-hook 'LaTeX-mode-hook #'TeX-source-correlate-mode)
  (add-hook 'LaTeX-mode-hook #'TeX-PDF-mode)
  (add-hook 'LaTeX-mode-hook #'visual-line-mode)
  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)

  (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t))
  (add-to-list 'TeX-command-list '("PDFLaTeX" "%`pdflatex -shell-escape%(mode)%' %t" TeX-run-TeX nil t))
  (add-to-list 'TeX-command-list '("Preview" "" (lambda (&rest args) (preview-document)) nil t))
  (add-to-list 'TeX-command-list '("Unpreview" "" (lambda (&rest args) (preview-clearout-document)) nil t))


  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs '(latex-mode "texlab"))))

(add-hook 'LaTeX-mode-hook #'eglot-ensure)

(use-package reftex
  :ensure nil
  :hook (LaTeX-mode . reftex-mode)
  :config
  (setq reftex-plug-into-AUCTeX t))

;; (use-package cdlatex
;;   :hook ((latex-mode LaTeX-mode) . turn-on-cdlatex)
;;   :config
;;   (setq cdlatex-command-alist
;;         '(("sum" "Insert \\sum_{}^{}"
;;            "\\sum_{?}^{}" cdlatex-position-cursor nil nil t)
;;           ("prd" "Insert \\prod_{}^{}"
;;            "\\prod_{?}^{}" cdlatex-position-cursor nil nil t))))

;; (setq TeX-insert-braces nil
;; TeX-arg-right-insert-p nil)

#+end_src
*** compilation
#+begin_src emacs-lisp

#+end_src
** verilog
#+begin_src emacs-lisp
;; (add-to-list 'eglot-server-programs
;;              '(verilog-mode . ("svlangserver" "--stdio")))
;; (setq verilog-linter "verible-verilog-lint")
;; (with-eval-after-load verilog-mode


(use-package flycheck
  :hook (emacs-startup . global-flycheck-mode)
  :config
  (defun k-flycheck-display-error-messages (errors)
    (message (flycheck-help-echo-all-error-messages errors)))
  (setq flycheck-display-errors-function #'k-flycheck-display-error-messages)
  (setq-default flycheck-indication-mode nil
                flycheck-global-modes '(emacs-lisp-mode
                                        verilog-mode))
  (advice-add 'flycheck-jump-to-error :before
              (lambda (_error)
                (unless (get-char-property (point) 'flycheck-error)
                  (push-mark)))))

(define-key flycheck-mode-map (kbd "M-g p") #'flycheck-previous-error)
(define-key flycheck-mode-map (kbd "M-g M-p") #'flycheck-previous-error)
(define-key flycheck-mode-map (kbd "M-g n") #'flycheck-next-error)
(define-key flycheck-mode-map (kbd "M-g M-n") #'flycheck-next-error)

;;(add-hook 'verilog-mode-hook #'flycheck-mode)
#+end_src
** calc
#+begin_src emacs-lisp
(use-package casual-calc
  :bind (:map calc-mode-map ("h" . #'casual-calc-tmenu)))

(setq calc-display-trail nil
      calc-multiplication-has-precedence nil)

;; input 0x16 will turn into 16#16
(defun calcDigit-X ()
  (interactive)
  (or (boundp 'calc-buffer)
      (use-local-map minibuffer-local-map))
  (if (string= "0" (minibuffer-contents-no-properties))
      (progn
        (delete-minibuffer-contents)
        (insert "16#"))
    (calcDigit-nondigit)))

(define-key calc-digit-map (kbd "x") #'calcDigit-X)

;; make quick calc use current line
(defun calc-do-quick-calc (&optional insert)
  (require 'calc-ext)
  (calc-check-defines)
  (if (eq major-mode 'calc-mode)
      (calc-algebraic-entry t)
    (let (buf
          shortbuf
          (string (string-replace "0x" "16#"
                                  (string-trim 
                                   (thing-at-point 'line)))))
      (save-excursion
	    (calc-create-buffer)
	    (let* ((calc-command-flags nil)
	           (calc-dollar-values calc-quick-prev-results)
	           (calc-dollar-used 0)
	           (enable-recursive-minibuffers t)
	           (calc-language (if (memq calc-language '(nil big))
				                  'flat calc-language))
	           (entry (calc-do-alg-entry (or string "") "Quick calc: " t 'calc-quick-calc-history))
	           (alg-exp (mapcar 'math-evaluate-expr entry)))
	      (when (and (= (length alg-exp) 1)
		             (eq (car-safe (car alg-exp)) 'calcFunc-assign)
		             (= (length (car alg-exp)) 3)
		             (eq (car-safe (nth 1 (car alg-exp))) 'var))
	        (set (nth 2 (nth 1 (car alg-exp))) (nth 2 (car alg-exp)))
	        (calc-refresh-evaltos (nth 2 (nth 1 (car alg-exp))))
	        (setq alg-exp (list (nth 2 (car alg-exp)))))
	      (setq calc-quick-prev-results alg-exp
                buf (mapconcat (lambda (x)
                                 (math-format-value x 1000))
			                   alg-exp
			                   " ")
		        shortbuf buf)
	      (if (and (= (length alg-exp) 1)
		           (memq (car-safe (car alg-exp)) '(nil))
		           (< (length buf) 20)
		           (= calc-number-radix 10))
	          (setq buf (concat buf "  ("
				                (let ((calc-number-radix 16))
				                  (math-format-value (car alg-exp) 1000))
				                ", "
				                (let ((calc-number-radix 8))
				                  (math-format-value (car alg-exp) 1000))
                                ", "
                                (let ((calc-number-radix 2))
                                  (math-format-value (car alg-exp) 1000))
				                (if (and (integerp (car alg-exp))
					                     (> (car alg-exp) 0)
					                     (< (car alg-exp) 127))
				                    (format ", \"%c\"" (car alg-exp))
				                  "")
				                ")")))
	      (if (and (< (length buf) (frame-width)) (= (length entry) 1)
		           (featurep 'calc-ext))
	          (let ((long (concat (math-format-value (car entry) 1000)
				                  " =>  " buf)))
		        (if (<= (length long) (- (frame-width) 8))
		            (setq buf long))))
	      (calc-handle-whys)
	      (message "Result: %s" buf)))
      (if (or insert
              (eq last-command-event 10))
	      (insert shortbuf)
        (kill-new shortbuf)))))
#+end_src
** dired
#+begin_src emacs-lisp
(use-package dired
  :ensure nil
  ;; :hook (dired-mode . dired-hide-details-mode)
  :custom
  (dired-dwim-target t)
  (dired-listing-switches "-alGhv --group-directories-first")
  (dired-recursive-copies 'always)
  (dired-kill-when-opening-new-dired-buffer t))

(use-package diredfl
  :hook (dired-mode . diredfl-global-mode))
#+end_src
** uniquify
#+begin_src emacs-lisp
(use-package uniquify
  :ensure nil
  :custom
  (uniquify-buffer-name-style 'reverse)
  (uniquify-separator " • ")
  (uniquify-after-kill-buffer-p t)
  (uniquify-ignore-buffers-re "^\\*"))
#+end_src
** ahk mode
#+begin_src emacs-lisp
(use-package ahk-mode
  :load-path "c:/Users/incubator/Projects/ahk-mode"
  :ensure nil)

(add-hook 'ahk-mode-hook #'eglot-ensure)
(add-to-list 'eglot-server-programs '(ahk-mode "node" "C:/Users/incubator/Projects/vscode-autohotkey2-lsp/server/dist/server.js" "--stdio"))

(define-key ahk-mode-map (kbd "C-M-\\") #'eglot-format-buffer)
#+end_src
** flowgraph-mode
#+begin_src emacs-lisp
(use-package flowgraph-mode
  :load-path "c:/Users/incubator/Projects/flowgraph-mode"
  :ensure nil)

#+end_src

